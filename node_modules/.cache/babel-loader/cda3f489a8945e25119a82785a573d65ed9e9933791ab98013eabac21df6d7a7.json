{"ast":null,"code":"import * as React from 'react';\nimport { createContext, useLayoutEffect, useRef, forwardRef, createElement, useContext, useImperativeHandle, useState, useCallback, useEffect, useMemo } from 'react';\n\n// The \"contextmenu\" event is not supported as a PointerEvent in all browsers yet, so MouseEvent still need to be handled\n\nconst PanelGroupContext = createContext(null);\nPanelGroupContext.displayName = \"PanelGroupContext\";\nconst DATA_ATTRIBUTES = {\n  group: \"data-panel-group\",\n  groupDirection: \"data-panel-group-direction\",\n  groupId: \"data-panel-group-id\",\n  panel: \"data-panel\",\n  panelCollapsible: \"data-panel-collapsible\",\n  panelId: \"data-panel-id\",\n  panelSize: \"data-panel-size\",\n  resizeHandle: \"data-resize-handle\",\n  resizeHandleActive: \"data-resize-handle-active\",\n  resizeHandleEnabled: \"data-panel-resize-handle-enabled\",\n  resizeHandleId: \"data-panel-resize-handle-id\",\n  resizeHandleState: \"data-resize-handle-state\"\n};\nconst PRECISION = 10;\nconst useIsomorphicLayoutEffect = useLayoutEffect;\nconst useId = React[\"useId\".toString()];\nconst wrappedUseId = typeof useId === \"function\" ? useId : () => null;\nlet counter = 0;\nfunction useUniqueId(idFromParams = null) {\n  const idFromUseId = wrappedUseId();\n  const idRef = useRef(idFromParams || idFromUseId || null);\n  if (idRef.current === null) {\n    idRef.current = \"\" + counter++;\n  }\n  return idFromParams !== null && idFromParams !== void 0 ? idFromParams : idRef.current;\n}\nfunction PanelWithForwardedRef({\n  children,\n  className: classNameFromProps = \"\",\n  collapsedSize,\n  collapsible,\n  defaultSize,\n  forwardedRef,\n  id: idFromProps,\n  maxSize,\n  minSize,\n  onCollapse,\n  onExpand,\n  onResize,\n  order,\n  style: styleFromProps,\n  tagName: Type = \"div\",\n  ...rest\n}) {\n  const context = useContext(PanelGroupContext);\n  if (context === null) {\n    throw Error(`Panel components must be rendered within a PanelGroup container`);\n  }\n  const {\n    collapsePanel,\n    expandPanel,\n    getPanelSize,\n    getPanelStyle,\n    groupId,\n    isPanelCollapsed,\n    reevaluatePanelConstraints,\n    registerPanel,\n    resizePanel,\n    unregisterPanel\n  } = context;\n  const panelId = useUniqueId(idFromProps);\n  const panelDataRef = useRef({\n    callbacks: {\n      onCollapse,\n      onExpand,\n      onResize\n    },\n    constraints: {\n      collapsedSize,\n      collapsible,\n      defaultSize,\n      maxSize,\n      minSize\n    },\n    id: panelId,\n    idIsFromProps: idFromProps !== undefined,\n    order\n  });\n  const devWarningsRef = useRef({\n    didLogMissingDefaultSizeWarning: false\n  });\n\n  // Normally we wouldn't log a warning during render,\n  // but effects don't run on the server, so we can't do it there\n  {\n    if (!devWarningsRef.current.didLogMissingDefaultSizeWarning) ;\n  }\n  useIsomorphicLayoutEffect(() => {\n    const {\n      callbacks,\n      constraints\n    } = panelDataRef.current;\n    const prevConstraints = {\n      ...constraints\n    };\n    panelDataRef.current.id = panelId;\n    panelDataRef.current.idIsFromProps = idFromProps !== undefined;\n    panelDataRef.current.order = order;\n    callbacks.onCollapse = onCollapse;\n    callbacks.onExpand = onExpand;\n    callbacks.onResize = onResize;\n    constraints.collapsedSize = collapsedSize;\n    constraints.collapsible = collapsible;\n    constraints.defaultSize = defaultSize;\n    constraints.maxSize = maxSize;\n    constraints.minSize = minSize;\n\n    // If constraints have changed, we should revisit panel sizes.\n    // This is uncommon but may happen if people are trying to implement pixel based constraints.\n    if (prevConstraints.collapsedSize !== constraints.collapsedSize || prevConstraints.collapsible !== constraints.collapsible || prevConstraints.maxSize !== constraints.maxSize || prevConstraints.minSize !== constraints.minSize) {\n      reevaluatePanelConstraints(panelDataRef.current, prevConstraints);\n    }\n  });\n  useIsomorphicLayoutEffect(() => {\n    const panelData = panelDataRef.current;\n    registerPanel(panelData);\n    return () => {\n      unregisterPanel(panelData);\n    };\n  }, [order, panelId, registerPanel, unregisterPanel]);\n  useImperativeHandle(forwardedRef, () => ({\n    collapse: () => {\n      collapsePanel(panelDataRef.current);\n    },\n    expand: minSize => {\n      expandPanel(panelDataRef.current, minSize);\n    },\n    getId() {\n      return panelId;\n    },\n    getSize() {\n      return getPanelSize(panelDataRef.current);\n    },\n    isCollapsed() {\n      return isPanelCollapsed(panelDataRef.current);\n    },\n    isExpanded() {\n      return !isPanelCollapsed(panelDataRef.current);\n    },\n    resize: size => {\n      resizePanel(panelDataRef.current, size);\n    }\n  }), [collapsePanel, expandPanel, getPanelSize, isPanelCollapsed, panelId, resizePanel]);\n  const style = getPanelStyle(panelDataRef.current, defaultSize);\n  return createElement(Type, {\n    ...rest,\n    children,\n    className: classNameFromProps,\n    id: panelId,\n    style: {\n      ...style,\n      ...styleFromProps\n    },\n    // CSS selectors\n    [DATA_ATTRIBUTES.groupId]: groupId,\n    [DATA_ATTRIBUTES.panel]: \"\",\n    [DATA_ATTRIBUTES.panelCollapsible]: collapsible || undefined,\n    [DATA_ATTRIBUTES.panelId]: panelId,\n    [DATA_ATTRIBUTES.panelSize]: parseFloat(\"\" + style.flexGrow).toFixed(1)\n  });\n}\nconst Panel = forwardRef((props, ref) => createElement(PanelWithForwardedRef, {\n  ...props,\n  forwardedRef: ref\n}));\nPanelWithForwardedRef.displayName = \"Panel\";\nPanel.displayName = \"forwardRef(Panel)\";\nlet nonce;\nfunction getNonce() {\n  return nonce;\n}\nfunction setNonce(value) {\n  nonce = value;\n}\nlet currentCursorStyle = null;\nlet enabled = true;\nlet prevRuleIndex = -1;\nlet styleElement = null;\nfunction disableGlobalCursorStyles() {\n  enabled = false;\n}\nfunction enableGlobalCursorStyles() {\n  enabled = true;\n}\nfunction getCursorStyle(state, constraintFlags) {\n  if (constraintFlags) {\n    const horizontalMin = (constraintFlags & EXCEEDED_HORIZONTAL_MIN) !== 0;\n    const horizontalMax = (constraintFlags & EXCEEDED_HORIZONTAL_MAX) !== 0;\n    const verticalMin = (constraintFlags & EXCEEDED_VERTICAL_MIN) !== 0;\n    const verticalMax = (constraintFlags & EXCEEDED_VERTICAL_MAX) !== 0;\n    if (horizontalMin) {\n      if (verticalMin) {\n        return \"se-resize\";\n      } else if (verticalMax) {\n        return \"ne-resize\";\n      } else {\n        return \"e-resize\";\n      }\n    } else if (horizontalMax) {\n      if (verticalMin) {\n        return \"sw-resize\";\n      } else if (verticalMax) {\n        return \"nw-resize\";\n      } else {\n        return \"w-resize\";\n      }\n    } else if (verticalMin) {\n      return \"s-resize\";\n    } else if (verticalMax) {\n      return \"n-resize\";\n    }\n  }\n  switch (state) {\n    case \"horizontal\":\n      return \"ew-resize\";\n    case \"intersection\":\n      return \"move\";\n    case \"vertical\":\n      return \"ns-resize\";\n  }\n}\nfunction resetGlobalCursorStyle() {\n  if (styleElement !== null) {\n    document.head.removeChild(styleElement);\n    currentCursorStyle = null;\n    styleElement = null;\n    prevRuleIndex = -1;\n  }\n}\nfunction setGlobalCursorStyle(state, constraintFlags) {\n  var _styleElement$sheet$i, _styleElement$sheet2;\n  if (!enabled) {\n    return;\n  }\n  const style = getCursorStyle(state, constraintFlags);\n  if (currentCursorStyle === style) {\n    return;\n  }\n  currentCursorStyle = style;\n  if (styleElement === null) {\n    styleElement = document.createElement(\"style\");\n    const nonce = getNonce();\n    if (nonce) {\n      styleElement.setAttribute(\"nonce\", nonce);\n    }\n    document.head.appendChild(styleElement);\n  }\n  if (prevRuleIndex >= 0) {\n    var _styleElement$sheet;\n    (_styleElement$sheet = styleElement.sheet) === null || _styleElement$sheet === void 0 ? void 0 : _styleElement$sheet.removeRule(prevRuleIndex);\n  }\n  prevRuleIndex = (_styleElement$sheet$i = (_styleElement$sheet2 = styleElement.sheet) === null || _styleElement$sheet2 === void 0 ? void 0 : _styleElement$sheet2.insertRule(`*{cursor: ${style} !important;}`)) !== null && _styleElement$sheet$i !== void 0 ? _styleElement$sheet$i : -1;\n}\nfunction isKeyDown(event) {\n  return event.type === \"keydown\";\n}\nfunction isPointerEvent(event) {\n  return event.type.startsWith(\"pointer\");\n}\nfunction isMouseEvent(event) {\n  return event.type.startsWith(\"mouse\");\n}\nfunction getResizeEventCoordinates(event) {\n  if (isPointerEvent(event)) {\n    if (event.isPrimary) {\n      return {\n        x: event.clientX,\n        y: event.clientY\n      };\n    }\n  } else if (isMouseEvent(event)) {\n    return {\n      x: event.clientX,\n      y: event.clientY\n    };\n  }\n  return {\n    x: Infinity,\n    y: Infinity\n  };\n}\nfunction getInputType() {\n  if (typeof matchMedia === \"function\") {\n    return matchMedia(\"(pointer:coarse)\").matches ? \"coarse\" : \"fine\";\n  }\n}\nfunction intersects(rectOne, rectTwo, strict) {\n  if (strict) {\n    return rectOne.x < rectTwo.x + rectTwo.width && rectOne.x + rectOne.width > rectTwo.x && rectOne.y < rectTwo.y + rectTwo.height && rectOne.y + rectOne.height > rectTwo.y;\n  } else {\n    return rectOne.x <= rectTwo.x + rectTwo.width && rectOne.x + rectOne.width >= rectTwo.x && rectOne.y <= rectTwo.y + rectTwo.height && rectOne.y + rectOne.height >= rectTwo.y;\n  }\n}\n\n// Forked from NPM stacking-order@2.0.0\n\n/**\n * Determine which of two nodes appears in front of the other —\n * if `a` is in front, returns 1, otherwise returns -1\n * @param {HTMLElement | SVGElement} a\n * @param {HTMLElement | SVGElement} b\n */\nfunction compare(a, b) {\n  if (a === b) throw new Error(\"Cannot compare node with itself\");\n  const ancestors = {\n    a: get_ancestors(a),\n    b: get_ancestors(b)\n  };\n  let common_ancestor;\n\n  // remove shared ancestors\n  while (ancestors.a.at(-1) === ancestors.b.at(-1)) {\n    a = ancestors.a.pop();\n    b = ancestors.b.pop();\n    common_ancestor = a;\n  }\n  assert(common_ancestor, \"Stacking order can only be calculated for elements with a common ancestor\");\n  const z_indexes = {\n    a: get_z_index(find_stacking_context(ancestors.a)),\n    b: get_z_index(find_stacking_context(ancestors.b))\n  };\n  if (z_indexes.a === z_indexes.b) {\n    const children = common_ancestor.childNodes;\n    const furthest_ancestors = {\n      a: ancestors.a.at(-1),\n      b: ancestors.b.at(-1)\n    };\n    let i = children.length;\n    while (i--) {\n      const child = children[i];\n      if (child === furthest_ancestors.a) return 1;\n      if (child === furthest_ancestors.b) return -1;\n    }\n  }\n  return Math.sign(z_indexes.a - z_indexes.b);\n}\nconst props = /\\b(?:position|zIndex|opacity|transform|webkitTransform|mixBlendMode|filter|webkitFilter|isolation)\\b/;\n\n/** @param {HTMLElement | SVGElement} node */\nfunction is_flex_item(node) {\n  var _get_parent;\n  // @ts-ignore\n  const display = getComputedStyle((_get_parent = get_parent(node)) !== null && _get_parent !== void 0 ? _get_parent : node).display;\n  return display === \"flex\" || display === \"inline-flex\";\n}\n\n/** @param {HTMLElement | SVGElement} node */\nfunction creates_stacking_context(node) {\n  const style = getComputedStyle(node);\n\n  // https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Positioning/Understanding_z_index/The_stacking_context\n  if (style.position === \"fixed\") return true;\n  // Forked to fix upstream bug https://github.com/Rich-Harris/stacking-order/issues/3\n  // if (\n  //   (style.zIndex !== \"auto\" && style.position !== \"static\") ||\n  //   is_flex_item(node)\n  // )\n  if (style.zIndex !== \"auto\" && (style.position !== \"static\" || is_flex_item(node))) return true;\n  if (+style.opacity < 1) return true;\n  if (\"transform\" in style && style.transform !== \"none\") return true;\n  if (\"webkitTransform\" in style && style.webkitTransform !== \"none\") return true;\n  if (\"mixBlendMode\" in style && style.mixBlendMode !== \"normal\") return true;\n  if (\"filter\" in style && style.filter !== \"none\") return true;\n  if (\"webkitFilter\" in style && style.webkitFilter !== \"none\") return true;\n  if (\"isolation\" in style && style.isolation === \"isolate\") return true;\n  if (props.test(style.willChange)) return true;\n  // @ts-expect-error\n  if (style.webkitOverflowScrolling === \"touch\") return true;\n  return false;\n}\n\n/** @param {(HTMLElement| SVGElement)[]} nodes */\nfunction find_stacking_context(nodes) {\n  let i = nodes.length;\n  while (i--) {\n    const node = nodes[i];\n    assert(node, \"Missing node\");\n    if (creates_stacking_context(node)) return node;\n  }\n  return null;\n}\n\n/** @param {HTMLElement | SVGElement} node */\nfunction get_z_index(node) {\n  return node && Number(getComputedStyle(node).zIndex) || 0;\n}\n\n/** @param {HTMLElement} node */\nfunction get_ancestors(node) {\n  const ancestors = [];\n  while (node) {\n    ancestors.push(node);\n    // @ts-ignore\n    node = get_parent(node);\n  }\n  return ancestors; // [ node, ... <body>, <html>, document ]\n}\n\n/** @param {HTMLElement} node */\nfunction get_parent(node) {\n  const {\n    parentNode\n  } = node;\n  if (parentNode && parentNode instanceof ShadowRoot) {\n    return parentNode.host;\n  }\n  return parentNode;\n}\nconst EXCEEDED_HORIZONTAL_MIN = 0b0001;\nconst EXCEEDED_HORIZONTAL_MAX = 0b0010;\nconst EXCEEDED_VERTICAL_MIN = 0b0100;\nconst EXCEEDED_VERTICAL_MAX = 0b1000;\nconst isCoarsePointer = getInputType() === \"coarse\";\nlet intersectingHandles = [];\nlet isPointerDown = false;\nlet ownerDocumentCounts = new Map();\nlet panelConstraintFlags = new Map();\nconst registeredResizeHandlers = new Set();\nfunction registerResizeHandle(resizeHandleId, element, direction, hitAreaMargins, setResizeHandlerState) {\n  var _ownerDocumentCounts$;\n  const {\n    ownerDocument\n  } = element;\n  const data = {\n    direction,\n    element,\n    hitAreaMargins,\n    setResizeHandlerState\n  };\n  const count = (_ownerDocumentCounts$ = ownerDocumentCounts.get(ownerDocument)) !== null && _ownerDocumentCounts$ !== void 0 ? _ownerDocumentCounts$ : 0;\n  ownerDocumentCounts.set(ownerDocument, count + 1);\n  registeredResizeHandlers.add(data);\n  updateListeners();\n  return function unregisterResizeHandle() {\n    var _ownerDocumentCounts$2;\n    panelConstraintFlags.delete(resizeHandleId);\n    registeredResizeHandlers.delete(data);\n    const count = (_ownerDocumentCounts$2 = ownerDocumentCounts.get(ownerDocument)) !== null && _ownerDocumentCounts$2 !== void 0 ? _ownerDocumentCounts$2 : 1;\n    ownerDocumentCounts.set(ownerDocument, count - 1);\n    updateListeners();\n    if (count === 1) {\n      ownerDocumentCounts.delete(ownerDocument);\n    }\n\n    // If the resize handle that is currently unmounting is intersecting with the pointer,\n    // update the global pointer to account for the change\n    if (intersectingHandles.includes(data)) {\n      const index = intersectingHandles.indexOf(data);\n      if (index >= 0) {\n        intersectingHandles.splice(index, 1);\n      }\n      updateCursor();\n\n      // Also instruct the handle to stop dragging; this prevents the parent group from being left in an inconsistent state\n      // See github.com/bvaughn/react-resizable-panels/issues/402\n      setResizeHandlerState(\"up\", true, null);\n    }\n  };\n}\nfunction handlePointerDown(event) {\n  const {\n    target\n  } = event;\n  const {\n    x,\n    y\n  } = getResizeEventCoordinates(event);\n  isPointerDown = true;\n  recalculateIntersectingHandles({\n    target,\n    x,\n    y\n  });\n  updateListeners();\n  if (intersectingHandles.length > 0) {\n    updateResizeHandlerStates(\"down\", event);\n    event.preventDefault();\n    if (!isWithinResizeHandle(target)) {\n      event.stopImmediatePropagation();\n    }\n  }\n}\nfunction handlePointerMove(event) {\n  const {\n    x,\n    y\n  } = getResizeEventCoordinates(event);\n\n  // Edge case (see #340)\n  // Detect when the pointer has been released outside an iframe on a different domain\n  if (isPointerDown && event.buttons === 0) {\n    isPointerDown = false;\n    updateResizeHandlerStates(\"up\", event);\n  }\n  if (!isPointerDown) {\n    const {\n      target\n    } = event;\n\n    // Recalculate intersecting handles whenever the pointer moves, except if it has already been pressed\n    // at that point, the handles may not move with the pointer (depending on constraints)\n    // but the same set of active handles should be locked until the pointer is released\n    recalculateIntersectingHandles({\n      target,\n      x,\n      y\n    });\n  }\n  updateResizeHandlerStates(\"move\", event);\n\n  // Update cursor based on return value(s) from active handles\n  updateCursor();\n  if (intersectingHandles.length > 0) {\n    event.preventDefault();\n  }\n}\nfunction handlePointerUp(event) {\n  const {\n    target\n  } = event;\n  const {\n    x,\n    y\n  } = getResizeEventCoordinates(event);\n  panelConstraintFlags.clear();\n  isPointerDown = false;\n  if (intersectingHandles.length > 0) {\n    event.preventDefault();\n    if (!isWithinResizeHandle(target)) {\n      event.stopImmediatePropagation();\n    }\n  }\n  updateResizeHandlerStates(\"up\", event);\n  recalculateIntersectingHandles({\n    target,\n    x,\n    y\n  });\n  updateCursor();\n  updateListeners();\n}\nfunction isWithinResizeHandle(element) {\n  let currentElement = element;\n  while (currentElement) {\n    if (currentElement.hasAttribute(DATA_ATTRIBUTES.resizeHandle)) {\n      return true;\n    }\n    currentElement = currentElement.parentElement;\n  }\n  return false;\n}\nfunction recalculateIntersectingHandles({\n  target,\n  x,\n  y\n}) {\n  intersectingHandles.splice(0);\n  let targetElement = null;\n  if (target instanceof HTMLElement || target instanceof SVGElement) {\n    targetElement = target;\n  }\n  registeredResizeHandlers.forEach(data => {\n    const {\n      element: dragHandleElement,\n      hitAreaMargins\n    } = data;\n    const dragHandleRect = dragHandleElement.getBoundingClientRect();\n    const {\n      bottom,\n      left,\n      right,\n      top\n    } = dragHandleRect;\n    const margin = isCoarsePointer ? hitAreaMargins.coarse : hitAreaMargins.fine;\n    const eventIntersects = x >= left - margin && x <= right + margin && y >= top - margin && y <= bottom + margin;\n    if (eventIntersects) {\n      // TRICKY\n      // We listen for pointers events at the root in order to support hit area margins\n      // (determining when the pointer is close enough to an element to be considered a \"hit\")\n      // Clicking on an element \"above\" a handle (e.g. a modal) should prevent a hit though\n      // so at this point we need to compare stacking order of a potentially intersecting drag handle,\n      // and the element that was actually clicked/touched\n      if (targetElement !== null && document.contains(targetElement) && dragHandleElement !== targetElement && !dragHandleElement.contains(targetElement) && !targetElement.contains(dragHandleElement) &&\n      // Calculating stacking order has a cost, so we should avoid it if possible\n      // That is why we only check potentially intersecting handles,\n      // and why we skip if the event target is within the handle's DOM\n      compare(targetElement, dragHandleElement) > 0) {\n        // If the target is above the drag handle, then we also need to confirm they overlap\n        // If they are beside each other (e.g. a panel and its drag handle) then the handle is still interactive\n        //\n        // It's not enough to compare only the target\n        // The target might be a small element inside of a larger container\n        // (For example, a SPAN or a DIV inside of a larger modal dialog)\n        let currentElement = targetElement;\n        let didIntersect = false;\n        while (currentElement) {\n          if (currentElement.contains(dragHandleElement)) {\n            break;\n          } else if (intersects(currentElement.getBoundingClientRect(), dragHandleRect, true)) {\n            didIntersect = true;\n            break;\n          }\n          currentElement = currentElement.parentElement;\n        }\n        if (didIntersect) {\n          return;\n        }\n      }\n      intersectingHandles.push(data);\n    }\n  });\n}\nfunction reportConstraintsViolation(resizeHandleId, flag) {\n  panelConstraintFlags.set(resizeHandleId, flag);\n}\nfunction updateCursor() {\n  let intersectsHorizontal = false;\n  let intersectsVertical = false;\n  intersectingHandles.forEach(data => {\n    const {\n      direction\n    } = data;\n    if (direction === \"horizontal\") {\n      intersectsHorizontal = true;\n    } else {\n      intersectsVertical = true;\n    }\n  });\n  let constraintFlags = 0;\n  panelConstraintFlags.forEach(flag => {\n    constraintFlags |= flag;\n  });\n  if (intersectsHorizontal && intersectsVertical) {\n    setGlobalCursorStyle(\"intersection\", constraintFlags);\n  } else if (intersectsHorizontal) {\n    setGlobalCursorStyle(\"horizontal\", constraintFlags);\n  } else if (intersectsVertical) {\n    setGlobalCursorStyle(\"vertical\", constraintFlags);\n  } else {\n    resetGlobalCursorStyle();\n  }\n}\nlet listenersAbortController;\nfunction updateListeners() {\n  var _listenersAbortContro;\n  (_listenersAbortContro = listenersAbortController) === null || _listenersAbortContro === void 0 ? void 0 : _listenersAbortContro.abort();\n  listenersAbortController = new AbortController();\n  const options = {\n    capture: true,\n    signal: listenersAbortController.signal\n  };\n  if (!registeredResizeHandlers.size) {\n    return;\n  }\n  if (isPointerDown) {\n    if (intersectingHandles.length > 0) {\n      ownerDocumentCounts.forEach((count, ownerDocument) => {\n        const {\n          body\n        } = ownerDocument;\n        if (count > 0) {\n          body.addEventListener(\"contextmenu\", handlePointerUp, options);\n          body.addEventListener(\"pointerleave\", handlePointerMove, options);\n          body.addEventListener(\"pointermove\", handlePointerMove, options);\n        }\n      });\n    }\n    ownerDocumentCounts.forEach((_, ownerDocument) => {\n      const {\n        body\n      } = ownerDocument;\n      body.addEventListener(\"pointerup\", handlePointerUp, options);\n      body.addEventListener(\"pointercancel\", handlePointerUp, options);\n    });\n  } else {\n    ownerDocumentCounts.forEach((count, ownerDocument) => {\n      const {\n        body\n      } = ownerDocument;\n      if (count > 0) {\n        body.addEventListener(\"pointerdown\", handlePointerDown, options);\n        body.addEventListener(\"pointermove\", handlePointerMove, options);\n      }\n    });\n  }\n}\nfunction updateResizeHandlerStates(action, event) {\n  registeredResizeHandlers.forEach(data => {\n    const {\n      setResizeHandlerState\n    } = data;\n    const isActive = intersectingHandles.includes(data);\n    setResizeHandlerState(action, isActive, event);\n  });\n}\nfunction useForceUpdate() {\n  const [_, setCount] = useState(0);\n  return useCallback(() => setCount(prevCount => prevCount + 1), []);\n}\nfunction assert(expectedCondition, message) {\n  if (!expectedCondition) {\n    console.error(message);\n    throw Error(message);\n  }\n}\nfunction fuzzyCompareNumbers(actual, expected, fractionDigits = PRECISION) {\n  if (actual.toFixed(fractionDigits) === expected.toFixed(fractionDigits)) {\n    return 0;\n  } else {\n    return actual > expected ? 1 : -1;\n  }\n}\nfunction fuzzyNumbersEqual$1(actual, expected, fractionDigits = PRECISION) {\n  return fuzzyCompareNumbers(actual, expected, fractionDigits) === 0;\n}\nfunction fuzzyNumbersEqual(actual, expected, fractionDigits) {\n  return fuzzyCompareNumbers(actual, expected, fractionDigits) === 0;\n}\nfunction fuzzyLayoutsEqual(actual, expected, fractionDigits) {\n  if (actual.length !== expected.length) {\n    return false;\n  }\n  for (let index = 0; index < actual.length; index++) {\n    const actualSize = actual[index];\n    const expectedSize = expected[index];\n    if (!fuzzyNumbersEqual(actualSize, expectedSize, fractionDigits)) {\n      return false;\n    }\n  }\n  return true;\n}\n\n// Panel size must be in percentages; pixel values should be pre-converted\nfunction resizePanel({\n  panelConstraints: panelConstraintsArray,\n  panelIndex,\n  size\n}) {\n  const panelConstraints = panelConstraintsArray[panelIndex];\n  assert(panelConstraints != null, `Panel constraints not found for index ${panelIndex}`);\n  let {\n    collapsedSize = 0,\n    collapsible,\n    maxSize = 100,\n    minSize = 0\n  } = panelConstraints;\n  if (fuzzyCompareNumbers(size, minSize) < 0) {\n    if (collapsible) {\n      // Collapsible panels should snap closed or open only once they cross the halfway point between collapsed and min size.\n      const halfwayPoint = (collapsedSize + minSize) / 2;\n      if (fuzzyCompareNumbers(size, halfwayPoint) < 0) {\n        size = collapsedSize;\n      } else {\n        size = minSize;\n      }\n    } else {\n      size = minSize;\n    }\n  }\n  size = Math.min(maxSize, size);\n  size = parseFloat(size.toFixed(PRECISION));\n  return size;\n}\n\n// All units must be in percentages; pixel values should be pre-converted\nfunction adjustLayoutByDelta({\n  delta,\n  initialLayout,\n  panelConstraints: panelConstraintsArray,\n  pivotIndices,\n  prevLayout,\n  trigger\n}) {\n  if (fuzzyNumbersEqual(delta, 0)) {\n    return initialLayout;\n  }\n  const nextLayout = [...initialLayout];\n  const [firstPivotIndex, secondPivotIndex] = pivotIndices;\n  assert(firstPivotIndex != null, \"Invalid first pivot index\");\n  assert(secondPivotIndex != null, \"Invalid second pivot index\");\n  let deltaApplied = 0;\n\n  // const DEBUG = [];\n  // DEBUG.push(`adjustLayoutByDelta()`);\n  // DEBUG.push(`  initialLayout: ${initialLayout.join(\", \")}`);\n  // DEBUG.push(`  prevLayout: ${prevLayout.join(\", \")}`);\n  // DEBUG.push(`  delta: ${delta}`);\n  // DEBUG.push(`  pivotIndices: ${pivotIndices.join(\", \")}`);\n  // DEBUG.push(`  trigger: ${trigger}`);\n  // DEBUG.push(\"\");\n\n  // A resizing panel affects the panels before or after it.\n  //\n  // A negative delta means the panel(s) immediately after the resize handle should grow/expand by decreasing its offset.\n  // Other panels may also need to shrink/contract (and shift) to make room, depending on the min weights.\n  //\n  // A positive delta means the panel(s) immediately before the resize handle should \"expand\".\n  // This is accomplished by shrinking/contracting (and shifting) one or more of the panels after the resize handle.\n\n  {\n    // If this is a resize triggered by a keyboard event, our logic for expanding/collapsing is different.\n    // We no longer check the halfway threshold because this may prevent the panel from expanding at all.\n    if (trigger === \"keyboard\") {\n      {\n        // Check if we should expand a collapsed panel\n        const index = delta < 0 ? secondPivotIndex : firstPivotIndex;\n        const panelConstraints = panelConstraintsArray[index];\n        assert(panelConstraints, `Panel constraints not found for index ${index}`);\n        const {\n          collapsedSize = 0,\n          collapsible,\n          minSize = 0\n        } = panelConstraints;\n\n        // DEBUG.push(`edge case check 1: ${index}`);\n        // DEBUG.push(`  -> collapsible? ${collapsible}`);\n        if (collapsible) {\n          const prevSize = initialLayout[index];\n          assert(prevSize != null, `Previous layout not found for panel index ${index}`);\n          if (fuzzyNumbersEqual(prevSize, collapsedSize)) {\n            const localDelta = minSize - prevSize;\n            // DEBUG.push(`  -> expand delta: ${localDelta}`);\n\n            if (fuzzyCompareNumbers(localDelta, Math.abs(delta)) > 0) {\n              delta = delta < 0 ? 0 - localDelta : localDelta;\n              // DEBUG.push(`  -> delta: ${delta}`);\n            }\n          }\n        }\n      }\n      {\n        // Check if we should collapse a panel at its minimum size\n        const index = delta < 0 ? firstPivotIndex : secondPivotIndex;\n        const panelConstraints = panelConstraintsArray[index];\n        assert(panelConstraints, `No panel constraints found for index ${index}`);\n        const {\n          collapsedSize = 0,\n          collapsible,\n          minSize = 0\n        } = panelConstraints;\n\n        // DEBUG.push(`edge case check 2: ${index}`);\n        // DEBUG.push(`  -> collapsible? ${collapsible}`);\n        if (collapsible) {\n          const prevSize = initialLayout[index];\n          assert(prevSize != null, `Previous layout not found for panel index ${index}`);\n          if (fuzzyNumbersEqual(prevSize, minSize)) {\n            const localDelta = prevSize - collapsedSize;\n            // DEBUG.push(`  -> expand delta: ${localDelta}`);\n\n            if (fuzzyCompareNumbers(localDelta, Math.abs(delta)) > 0) {\n              delta = delta < 0 ? 0 - localDelta : localDelta;\n              // DEBUG.push(`  -> delta: ${delta}`);\n            }\n          }\n        }\n      }\n    }\n    // DEBUG.push(\"\");\n  }\n  {\n    // Pre-calculate max available delta in the opposite direction of our pivot.\n    // This will be the maximum amount we're allowed to expand/contract the panels in the primary direction.\n    // If this amount is less than the requested delta, adjust the requested delta.\n    // If this amount is greater than the requested delta, that's useful information too–\n    // as an expanding panel might change from collapsed to min size.\n\n    const increment = delta < 0 ? 1 : -1;\n    let index = delta < 0 ? secondPivotIndex : firstPivotIndex;\n    let maxAvailableDelta = 0;\n\n    // DEBUG.push(\"pre calc...\");\n    while (true) {\n      const prevSize = initialLayout[index];\n      assert(prevSize != null, `Previous layout not found for panel index ${index}`);\n      const maxSafeSize = resizePanel({\n        panelConstraints: panelConstraintsArray,\n        panelIndex: index,\n        size: 100\n      });\n      const delta = maxSafeSize - prevSize;\n      // DEBUG.push(`  ${index}: ${prevSize} -> ${maxSafeSize}`);\n\n      maxAvailableDelta += delta;\n      index += increment;\n      if (index < 0 || index >= panelConstraintsArray.length) {\n        break;\n      }\n    }\n\n    // DEBUG.push(`  -> max available delta: ${maxAvailableDelta}`);\n    const minAbsDelta = Math.min(Math.abs(delta), Math.abs(maxAvailableDelta));\n    delta = delta < 0 ? 0 - minAbsDelta : minAbsDelta;\n    // DEBUG.push(`  -> adjusted delta: ${delta}`);\n    // DEBUG.push(\"\");\n  }\n  {\n    // Delta added to a panel needs to be subtracted from other panels (within the constraints that those panels allow).\n\n    const pivotIndex = delta < 0 ? firstPivotIndex : secondPivotIndex;\n    let index = pivotIndex;\n    while (index >= 0 && index < panelConstraintsArray.length) {\n      const deltaRemaining = Math.abs(delta) - Math.abs(deltaApplied);\n      const prevSize = initialLayout[index];\n      assert(prevSize != null, `Previous layout not found for panel index ${index}`);\n      const unsafeSize = prevSize - deltaRemaining;\n      const safeSize = resizePanel({\n        panelConstraints: panelConstraintsArray,\n        panelIndex: index,\n        size: unsafeSize\n      });\n      if (!fuzzyNumbersEqual(prevSize, safeSize)) {\n        deltaApplied += prevSize - safeSize;\n        nextLayout[index] = safeSize;\n        if (deltaApplied.toPrecision(3).localeCompare(Math.abs(delta).toPrecision(3), undefined, {\n          numeric: true\n        }) >= 0) {\n          break;\n        }\n      }\n      if (delta < 0) {\n        index--;\n      } else {\n        index++;\n      }\n    }\n  }\n  // DEBUG.push(`after 1: ${nextLayout.join(\", \")}`);\n  // DEBUG.push(`  deltaApplied: ${deltaApplied}`);\n  // DEBUG.push(\"\");\n\n  // If we were unable to resize any of the panels panels, return the previous state.\n  // This will essentially bailout and ignore e.g. drags past a panel's boundaries\n  if (fuzzyLayoutsEqual(prevLayout, nextLayout)) {\n    // DEBUG.push(`bailout to previous layout: ${prevLayout.join(\", \")}`);\n    // console.log(DEBUG.join(\"\\n\"));\n\n    return prevLayout;\n  }\n  {\n    // Now distribute the applied delta to the panels in the other direction\n    const pivotIndex = delta < 0 ? secondPivotIndex : firstPivotIndex;\n    const prevSize = initialLayout[pivotIndex];\n    assert(prevSize != null, `Previous layout not found for panel index ${pivotIndex}`);\n    const unsafeSize = prevSize + deltaApplied;\n    const safeSize = resizePanel({\n      panelConstraints: panelConstraintsArray,\n      panelIndex: pivotIndex,\n      size: unsafeSize\n    });\n\n    // Adjust the pivot panel before, but only by the amount that surrounding panels were able to shrink/contract.\n    nextLayout[pivotIndex] = safeSize;\n\n    // Edge case where expanding or contracting one panel caused another one to change collapsed state\n    if (!fuzzyNumbersEqual(safeSize, unsafeSize)) {\n      let deltaRemaining = unsafeSize - safeSize;\n      const pivotIndex = delta < 0 ? secondPivotIndex : firstPivotIndex;\n      let index = pivotIndex;\n      while (index >= 0 && index < panelConstraintsArray.length) {\n        const prevSize = nextLayout[index];\n        assert(prevSize != null, `Previous layout not found for panel index ${index}`);\n        const unsafeSize = prevSize + deltaRemaining;\n        const safeSize = resizePanel({\n          panelConstraints: panelConstraintsArray,\n          panelIndex: index,\n          size: unsafeSize\n        });\n        if (!fuzzyNumbersEqual(prevSize, safeSize)) {\n          deltaRemaining -= safeSize - prevSize;\n          nextLayout[index] = safeSize;\n        }\n        if (fuzzyNumbersEqual(deltaRemaining, 0)) {\n          break;\n        }\n        if (delta > 0) {\n          index--;\n        } else {\n          index++;\n        }\n      }\n    }\n  }\n  // DEBUG.push(`after 2: ${nextLayout.join(\", \")}`);\n  // DEBUG.push(`  deltaApplied: ${deltaApplied}`);\n  // DEBUG.push(\"\");\n\n  const totalSize = nextLayout.reduce((total, size) => size + total, 0);\n  // DEBUG.push(`total size: ${totalSize}`);\n\n  // If our new layout doesn't add up to 100%, that means the requested delta can't be applied\n  // In that case, fall back to our most recent valid layout\n  if (!fuzzyNumbersEqual(totalSize, 100)) {\n    // DEBUG.push(`bailout to previous layout: ${prevLayout.join(\", \")}`);\n    // console.log(DEBUG.join(\"\\n\"));\n\n    return prevLayout;\n  }\n\n  // console.log(DEBUG.join(\"\\n\"));\n  return nextLayout;\n}\nfunction calculateAriaValues({\n  layout,\n  panelsArray,\n  pivotIndices\n}) {\n  let currentMinSize = 0;\n  let currentMaxSize = 100;\n  let totalMinSize = 0;\n  let totalMaxSize = 0;\n  const firstIndex = pivotIndices[0];\n  assert(firstIndex != null, \"No pivot index found\");\n\n  // A panel's effective min/max sizes also need to account for other panel's sizes.\n  panelsArray.forEach((panelData, index) => {\n    const {\n      constraints\n    } = panelData;\n    const {\n      maxSize = 100,\n      minSize = 0\n    } = constraints;\n    if (index === firstIndex) {\n      currentMinSize = minSize;\n      currentMaxSize = maxSize;\n    } else {\n      totalMinSize += minSize;\n      totalMaxSize += maxSize;\n    }\n  });\n  const valueMax = Math.min(currentMaxSize, 100 - totalMinSize);\n  const valueMin = Math.max(currentMinSize, 100 - totalMaxSize);\n  const valueNow = layout[firstIndex];\n  return {\n    valueMax,\n    valueMin,\n    valueNow\n  };\n}\nfunction getResizeHandleElementsForGroup(groupId, scope = document) {\n  return Array.from(scope.querySelectorAll(`[${DATA_ATTRIBUTES.resizeHandleId}][data-panel-group-id=\"${groupId}\"]`));\n}\nfunction getResizeHandleElementIndex(groupId, id, scope = document) {\n  const handles = getResizeHandleElementsForGroup(groupId, scope);\n  const index = handles.findIndex(handle => handle.getAttribute(DATA_ATTRIBUTES.resizeHandleId) === id);\n  return index !== null && index !== void 0 ? index : null;\n}\nfunction determinePivotIndices(groupId, dragHandleId, panelGroupElement) {\n  const index = getResizeHandleElementIndex(groupId, dragHandleId, panelGroupElement);\n  return index != null ? [index, index + 1] : [-1, -1];\n}\nfunction isHTMLElement(target) {\n  if (target instanceof HTMLElement) {\n    return true;\n  }\n\n  // Fallback to duck typing to handle edge case of portals within a popup window\n  return typeof target === \"object\" && target !== null && \"tagName\" in target && \"getAttribute\" in target;\n}\nfunction getPanelGroupElement(id, rootElement = document) {\n  // If the root element is the PanelGroup\n  if (isHTMLElement(rootElement) && rootElement.dataset.panelGroupId == id) {\n    return rootElement;\n  }\n\n  // Else query children\n  const element = rootElement.querySelector(`[data-panel-group][data-panel-group-id=\"${id}\"]`);\n  if (element) {\n    return element;\n  }\n  return null;\n}\nfunction getResizeHandleElement(id, scope = document) {\n  const element = scope.querySelector(`[${DATA_ATTRIBUTES.resizeHandleId}=\"${id}\"]`);\n  if (element) {\n    return element;\n  }\n  return null;\n}\nfunction getResizeHandlePanelIds(groupId, handleId, panelsArray, scope = document) {\n  var _panelsArray$index$id, _panelsArray$index, _panelsArray$id, _panelsArray;\n  const handle = getResizeHandleElement(handleId, scope);\n  const handles = getResizeHandleElementsForGroup(groupId, scope);\n  const index = handle ? handles.indexOf(handle) : -1;\n  const idBefore = (_panelsArray$index$id = (_panelsArray$index = panelsArray[index]) === null || _panelsArray$index === void 0 ? void 0 : _panelsArray$index.id) !== null && _panelsArray$index$id !== void 0 ? _panelsArray$index$id : null;\n  const idAfter = (_panelsArray$id = (_panelsArray = panelsArray[index + 1]) === null || _panelsArray === void 0 ? void 0 : _panelsArray.id) !== null && _panelsArray$id !== void 0 ? _panelsArray$id : null;\n  return [idBefore, idAfter];\n}\n\n// https://www.w3.org/WAI/ARIA/apg/patterns/windowsplitter/\n\nfunction useWindowSplitterPanelGroupBehavior({\n  committedValuesRef,\n  eagerValuesRef,\n  groupId,\n  layout,\n  panelDataArray,\n  panelGroupElement,\n  setLayout\n}) {\n  const devWarningsRef = useRef({\n    didWarnAboutMissingResizeHandle: false\n  });\n  useIsomorphicLayoutEffect(() => {\n    if (!panelGroupElement) {\n      return;\n    }\n    const resizeHandleElements = getResizeHandleElementsForGroup(groupId, panelGroupElement);\n    for (let index = 0; index < panelDataArray.length - 1; index++) {\n      const {\n        valueMax,\n        valueMin,\n        valueNow\n      } = calculateAriaValues({\n        layout,\n        panelsArray: panelDataArray,\n        pivotIndices: [index, index + 1]\n      });\n      const resizeHandleElement = resizeHandleElements[index];\n      if (resizeHandleElement == null) {\n        {\n          const {\n            didWarnAboutMissingResizeHandle\n          } = devWarningsRef.current;\n          if (!didWarnAboutMissingResizeHandle) {\n            devWarningsRef.current.didWarnAboutMissingResizeHandle = true;\n            console.warn(`WARNING: Missing resize handle for PanelGroup \"${groupId}\"`);\n          }\n        }\n      } else {\n        const panelData = panelDataArray[index];\n        assert(panelData, `No panel data found for index \"${index}\"`);\n        resizeHandleElement.setAttribute(\"aria-controls\", panelData.id);\n        resizeHandleElement.setAttribute(\"aria-valuemax\", \"\" + Math.round(valueMax));\n        resizeHandleElement.setAttribute(\"aria-valuemin\", \"\" + Math.round(valueMin));\n        resizeHandleElement.setAttribute(\"aria-valuenow\", valueNow != null ? \"\" + Math.round(valueNow) : \"\");\n      }\n    }\n    return () => {\n      resizeHandleElements.forEach((resizeHandleElement, index) => {\n        resizeHandleElement.removeAttribute(\"aria-controls\");\n        resizeHandleElement.removeAttribute(\"aria-valuemax\");\n        resizeHandleElement.removeAttribute(\"aria-valuemin\");\n        resizeHandleElement.removeAttribute(\"aria-valuenow\");\n      });\n    };\n  }, [groupId, layout, panelDataArray, panelGroupElement]);\n  useEffect(() => {\n    if (!panelGroupElement) {\n      return;\n    }\n    const eagerValues = eagerValuesRef.current;\n    assert(eagerValues, `Eager values not found`);\n    const {\n      panelDataArray\n    } = eagerValues;\n    const groupElement = getPanelGroupElement(groupId, panelGroupElement);\n    assert(groupElement != null, `No group found for id \"${groupId}\"`);\n    const handles = getResizeHandleElementsForGroup(groupId, panelGroupElement);\n    assert(handles, `No resize handles found for group id \"${groupId}\"`);\n    const cleanupFunctions = handles.map(handle => {\n      const handleId = handle.getAttribute(DATA_ATTRIBUTES.resizeHandleId);\n      assert(handleId, `Resize handle element has no handle id attribute`);\n      const [idBefore, idAfter] = getResizeHandlePanelIds(groupId, handleId, panelDataArray, panelGroupElement);\n      if (idBefore == null || idAfter == null) {\n        return () => {};\n      }\n      const onKeyDown = event => {\n        if (event.defaultPrevented) {\n          return;\n        }\n        switch (event.key) {\n          case \"Enter\":\n            {\n              event.preventDefault();\n              const index = panelDataArray.findIndex(panelData => panelData.id === idBefore);\n              if (index >= 0) {\n                const panelData = panelDataArray[index];\n                assert(panelData, `No panel data found for index ${index}`);\n                const size = layout[index];\n                const {\n                  collapsedSize = 0,\n                  collapsible,\n                  minSize = 0\n                } = panelData.constraints;\n                if (size != null && collapsible) {\n                  const nextLayout = adjustLayoutByDelta({\n                    delta: fuzzyNumbersEqual(size, collapsedSize) ? minSize - collapsedSize : collapsedSize - size,\n                    initialLayout: layout,\n                    panelConstraints: panelDataArray.map(panelData => panelData.constraints),\n                    pivotIndices: determinePivotIndices(groupId, handleId, panelGroupElement),\n                    prevLayout: layout,\n                    trigger: \"keyboard\"\n                  });\n                  if (layout !== nextLayout) {\n                    setLayout(nextLayout);\n                  }\n                }\n              }\n              break;\n            }\n        }\n      };\n      handle.addEventListener(\"keydown\", onKeyDown);\n      return () => {\n        handle.removeEventListener(\"keydown\", onKeyDown);\n      };\n    });\n    return () => {\n      cleanupFunctions.forEach(cleanupFunction => cleanupFunction());\n    };\n  }, [panelGroupElement, committedValuesRef, eagerValuesRef, groupId, layout, panelDataArray, setLayout]);\n}\nfunction areEqual(arrayA, arrayB) {\n  if (arrayA.length !== arrayB.length) {\n    return false;\n  }\n  for (let index = 0; index < arrayA.length; index++) {\n    if (arrayA[index] !== arrayB[index]) {\n      return false;\n    }\n  }\n  return true;\n}\nfunction getResizeEventCursorPosition(direction, event) {\n  const isHorizontal = direction === \"horizontal\";\n  const {\n    x,\n    y\n  } = getResizeEventCoordinates(event);\n  return isHorizontal ? x : y;\n}\nfunction calculateDragOffsetPercentage(event, dragHandleId, direction, initialDragState, panelGroupElement) {\n  const isHorizontal = direction === \"horizontal\";\n  const handleElement = getResizeHandleElement(dragHandleId, panelGroupElement);\n  assert(handleElement, `No resize handle element found for id \"${dragHandleId}\"`);\n  const groupId = handleElement.getAttribute(DATA_ATTRIBUTES.groupId);\n  assert(groupId, `Resize handle element has no group id attribute`);\n  let {\n    initialCursorPosition\n  } = initialDragState;\n  const cursorPosition = getResizeEventCursorPosition(direction, event);\n  const groupElement = getPanelGroupElement(groupId, panelGroupElement);\n  assert(groupElement, `No group element found for id \"${groupId}\"`);\n  const groupRect = groupElement.getBoundingClientRect();\n  const groupSizeInPixels = isHorizontal ? groupRect.width : groupRect.height;\n  const offsetPixels = cursorPosition - initialCursorPosition;\n  const offsetPercentage = offsetPixels / groupSizeInPixels * 100;\n  return offsetPercentage;\n}\n\n// https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/movementX\nfunction calculateDeltaPercentage(event, dragHandleId, direction, initialDragState, keyboardResizeBy, panelGroupElement) {\n  if (isKeyDown(event)) {\n    const isHorizontal = direction === \"horizontal\";\n    let delta = 0;\n    if (event.shiftKey) {\n      delta = 100;\n    } else if (keyboardResizeBy != null) {\n      delta = keyboardResizeBy;\n    } else {\n      delta = 10;\n    }\n    let movement = 0;\n    switch (event.key) {\n      case \"ArrowDown\":\n        movement = isHorizontal ? 0 : delta;\n        break;\n      case \"ArrowLeft\":\n        movement = isHorizontal ? -delta : 0;\n        break;\n      case \"ArrowRight\":\n        movement = isHorizontal ? delta : 0;\n        break;\n      case \"ArrowUp\":\n        movement = isHorizontal ? 0 : -delta;\n        break;\n      case \"End\":\n        movement = 100;\n        break;\n      case \"Home\":\n        movement = -100;\n        break;\n    }\n    return movement;\n  } else {\n    if (initialDragState == null) {\n      return 0;\n    }\n    return calculateDragOffsetPercentage(event, dragHandleId, direction, initialDragState, panelGroupElement);\n  }\n}\nfunction calculateUnsafeDefaultLayout({\n  panelDataArray\n}) {\n  const layout = Array(panelDataArray.length);\n  const panelConstraintsArray = panelDataArray.map(panelData => panelData.constraints);\n  let numPanelsWithSizes = 0;\n  let remainingSize = 100;\n\n  // Distribute default sizes first\n  for (let index = 0; index < panelDataArray.length; index++) {\n    const panelConstraints = panelConstraintsArray[index];\n    assert(panelConstraints, `Panel constraints not found for index ${index}`);\n    const {\n      defaultSize\n    } = panelConstraints;\n    if (defaultSize != null) {\n      numPanelsWithSizes++;\n      layout[index] = defaultSize;\n      remainingSize -= defaultSize;\n    }\n  }\n\n  // Remaining size should be distributed evenly between panels without default sizes\n  for (let index = 0; index < panelDataArray.length; index++) {\n    const panelConstraints = panelConstraintsArray[index];\n    assert(panelConstraints, `Panel constraints not found for index ${index}`);\n    const {\n      defaultSize\n    } = panelConstraints;\n    if (defaultSize != null) {\n      continue;\n    }\n    const numRemainingPanels = panelDataArray.length - numPanelsWithSizes;\n    const size = remainingSize / numRemainingPanels;\n    numPanelsWithSizes++;\n    layout[index] = size;\n    remainingSize -= size;\n  }\n  return layout;\n}\n\n// Layout should be pre-converted into percentages\nfunction callPanelCallbacks(panelsArray, layout, panelIdToLastNotifiedSizeMap) {\n  layout.forEach((size, index) => {\n    const panelData = panelsArray[index];\n    assert(panelData, `Panel data not found for index ${index}`);\n    const {\n      callbacks,\n      constraints,\n      id: panelId\n    } = panelData;\n    const {\n      collapsedSize = 0,\n      collapsible\n    } = constraints;\n    const lastNotifiedSize = panelIdToLastNotifiedSizeMap[panelId];\n    if (lastNotifiedSize == null || size !== lastNotifiedSize) {\n      panelIdToLastNotifiedSizeMap[panelId] = size;\n      const {\n        onCollapse,\n        onExpand,\n        onResize\n      } = callbacks;\n      if (onResize) {\n        onResize(size, lastNotifiedSize);\n      }\n      if (collapsible && (onCollapse || onExpand)) {\n        if (onExpand && (lastNotifiedSize == null || fuzzyNumbersEqual$1(lastNotifiedSize, collapsedSize)) && !fuzzyNumbersEqual$1(size, collapsedSize)) {\n          onExpand();\n        }\n        if (onCollapse && (lastNotifiedSize == null || !fuzzyNumbersEqual$1(lastNotifiedSize, collapsedSize)) && fuzzyNumbersEqual$1(size, collapsedSize)) {\n          onCollapse();\n        }\n      }\n    }\n  });\n}\nfunction compareLayouts(a, b) {\n  if (a.length !== b.length) {\n    return false;\n  } else {\n    for (let index = 0; index < a.length; index++) {\n      if (a[index] != b[index]) {\n        return false;\n      }\n    }\n  }\n  return true;\n}\n\n// This method returns a number between 1 and 100 representing\n\n// the % of the group's overall space this panel should occupy.\nfunction computePanelFlexBoxStyle({\n  defaultSize,\n  dragState,\n  layout,\n  panelData,\n  panelIndex,\n  precision = 3\n}) {\n  const size = layout[panelIndex];\n  let flexGrow;\n  if (size == null) {\n    // Initial render (before panels have registered themselves)\n    // In order to support server rendering, fall back to default size if provided\n    flexGrow = defaultSize != undefined ? defaultSize.toPrecision(precision) : \"1\";\n  } else if (panelData.length === 1) {\n    // Special case: Single panel group should always fill full width/height\n    flexGrow = \"1\";\n  } else {\n    flexGrow = size.toPrecision(precision);\n  }\n  return {\n    flexBasis: 0,\n    flexGrow,\n    flexShrink: 1,\n    // Without this, Panel sizes may be unintentionally overridden by their content\n    overflow: \"hidden\",\n    // Disable pointer events inside of a panel during resize\n    // This avoid edge cases like nested iframes\n    pointerEvents: dragState !== null ? \"none\" : undefined\n  };\n}\nfunction debounce(callback, durationMs = 10) {\n  let timeoutId = null;\n  let callable = (...args) => {\n    if (timeoutId !== null) {\n      clearTimeout(timeoutId);\n    }\n    timeoutId = setTimeout(() => {\n      callback(...args);\n    }, durationMs);\n  };\n  return callable;\n}\n\n// PanelGroup might be rendering in a server-side environment where localStorage is not available\n// or on a browser with cookies/storage disabled.\n// In either case, this function avoids accessing localStorage until needed,\n// and avoids throwing user-visible errors.\nfunction initializeDefaultStorage(storageObject) {\n  try {\n    if (typeof localStorage !== \"undefined\") {\n      // Bypass this check for future calls\n      storageObject.getItem = name => {\n        return localStorage.getItem(name);\n      };\n      storageObject.setItem = (name, value) => {\n        localStorage.setItem(name, value);\n      };\n    } else {\n      throw new Error(\"localStorage not supported in this environment\");\n    }\n  } catch (error) {\n    console.error(error);\n    storageObject.getItem = () => null;\n    storageObject.setItem = () => {};\n  }\n}\nfunction getPanelGroupKey(autoSaveId) {\n  return `react-resizable-panels:${autoSaveId}`;\n}\n\n// Note that Panel ids might be user-provided (stable) or useId generated (non-deterministic)\n// so they should not be used as part of the serialization key.\n// Using the min/max size attributes should work well enough as a backup.\n// Pre-sorting by minSize allows remembering layouts even if panels are re-ordered/dragged.\nfunction getPanelKey(panels) {\n  return panels.map(panel => {\n    const {\n      constraints,\n      id,\n      idIsFromProps,\n      order\n    } = panel;\n    if (idIsFromProps) {\n      return id;\n    } else {\n      return order ? `${order}:${JSON.stringify(constraints)}` : JSON.stringify(constraints);\n    }\n  }).sort((a, b) => a.localeCompare(b)).join(\",\");\n}\nfunction loadSerializedPanelGroupState(autoSaveId, storage) {\n  try {\n    const panelGroupKey = getPanelGroupKey(autoSaveId);\n    const serialized = storage.getItem(panelGroupKey);\n    if (serialized) {\n      const parsed = JSON.parse(serialized);\n      if (typeof parsed === \"object\" && parsed != null) {\n        return parsed;\n      }\n    }\n  } catch (error) {}\n  return null;\n}\nfunction loadPanelGroupState(autoSaveId, panels, storage) {\n  var _loadSerializedPanelG, _state$panelKey;\n  const state = (_loadSerializedPanelG = loadSerializedPanelGroupState(autoSaveId, storage)) !== null && _loadSerializedPanelG !== void 0 ? _loadSerializedPanelG : {};\n  const panelKey = getPanelKey(panels);\n  return (_state$panelKey = state[panelKey]) !== null && _state$panelKey !== void 0 ? _state$panelKey : null;\n}\nfunction savePanelGroupState(autoSaveId, panels, panelSizesBeforeCollapse, sizes, storage) {\n  var _loadSerializedPanelG2;\n  const panelGroupKey = getPanelGroupKey(autoSaveId);\n  const panelKey = getPanelKey(panels);\n  const state = (_loadSerializedPanelG2 = loadSerializedPanelGroupState(autoSaveId, storage)) !== null && _loadSerializedPanelG2 !== void 0 ? _loadSerializedPanelG2 : {};\n  state[panelKey] = {\n    expandToSizes: Object.fromEntries(panelSizesBeforeCollapse.entries()),\n    layout: sizes\n  };\n  try {\n    storage.setItem(panelGroupKey, JSON.stringify(state));\n  } catch (error) {\n    console.error(error);\n  }\n}\nfunction validatePanelConstraints({\n  panelConstraints: panelConstraintsArray,\n  panelId,\n  panelIndex\n}) {\n  {\n    const warnings = [];\n    const panelConstraints = panelConstraintsArray[panelIndex];\n    assert(panelConstraints, `No panel constraints found for index ${panelIndex}`);\n    const {\n      collapsedSize = 0,\n      collapsible = false,\n      defaultSize,\n      maxSize = 100,\n      minSize = 0\n    } = panelConstraints;\n    if (minSize > maxSize) {\n      warnings.push(`min size (${minSize}%) should not be greater than max size (${maxSize}%)`);\n    }\n    if (defaultSize != null) {\n      if (defaultSize < 0) {\n        warnings.push(\"default size should not be less than 0\");\n      } else if (defaultSize < minSize && (!collapsible || defaultSize !== collapsedSize)) {\n        warnings.push(\"default size should not be less than min size\");\n      }\n      if (defaultSize > 100) {\n        warnings.push(\"default size should not be greater than 100\");\n      } else if (defaultSize > maxSize) {\n        warnings.push(\"default size should not be greater than max size\");\n      }\n    }\n    if (collapsedSize > minSize) {\n      warnings.push(\"collapsed size should not be greater than min size\");\n    }\n    if (warnings.length > 0) {\n      const name = panelId != null ? `Panel \"${panelId}\"` : \"Panel\";\n      console.warn(`${name} has an invalid configuration:\\n\\n${warnings.join(\"\\n\")}`);\n      return false;\n    }\n  }\n  return true;\n}\n\n// All units must be in percentages; pixel values should be pre-converted\nfunction validatePanelGroupLayout({\n  layout: prevLayout,\n  panelConstraints\n}) {\n  const nextLayout = [...prevLayout];\n  const nextLayoutTotalSize = nextLayout.reduce((accumulated, current) => accumulated + current, 0);\n\n  // Validate layout expectations\n  if (nextLayout.length !== panelConstraints.length) {\n    throw Error(`Invalid ${panelConstraints.length} panel layout: ${nextLayout.map(size => `${size}%`).join(\", \")}`);\n  } else if (!fuzzyNumbersEqual(nextLayoutTotalSize, 100) && nextLayout.length > 0) {\n    // This is not ideal so we should warn about it, but it may be recoverable in some cases\n    // (especially if the amount is small)\n    {\n      console.warn(`WARNING: Invalid layout total size: ${nextLayout.map(size => `${size}%`).join(\", \")}. Layout normalization will be applied.`);\n    }\n    for (let index = 0; index < panelConstraints.length; index++) {\n      const unsafeSize = nextLayout[index];\n      assert(unsafeSize != null, `No layout data found for index ${index}`);\n      const safeSize = 100 / nextLayoutTotalSize * unsafeSize;\n      nextLayout[index] = safeSize;\n    }\n  }\n  let remainingSize = 0;\n\n  // First pass: Validate the proposed layout given each panel's constraints\n  for (let index = 0; index < panelConstraints.length; index++) {\n    const unsafeSize = nextLayout[index];\n    assert(unsafeSize != null, `No layout data found for index ${index}`);\n    const safeSize = resizePanel({\n      panelConstraints,\n      panelIndex: index,\n      size: unsafeSize\n    });\n    if (unsafeSize != safeSize) {\n      remainingSize += unsafeSize - safeSize;\n      nextLayout[index] = safeSize;\n    }\n  }\n\n  // If there is additional, left over space, assign it to any panel(s) that permits it\n  // (It's not worth taking multiple additional passes to evenly distribute)\n  if (!fuzzyNumbersEqual(remainingSize, 0)) {\n    for (let index = 0; index < panelConstraints.length; index++) {\n      const prevSize = nextLayout[index];\n      assert(prevSize != null, `No layout data found for index ${index}`);\n      const unsafeSize = prevSize + remainingSize;\n      const safeSize = resizePanel({\n        panelConstraints,\n        panelIndex: index,\n        size: unsafeSize\n      });\n      if (prevSize !== safeSize) {\n        remainingSize -= safeSize - prevSize;\n        nextLayout[index] = safeSize;\n\n        // Once we've used up the remainder, bail\n        if (fuzzyNumbersEqual(remainingSize, 0)) {\n          break;\n        }\n      }\n    }\n  }\n  return nextLayout;\n}\nconst LOCAL_STORAGE_DEBOUNCE_INTERVAL = 100;\nconst defaultStorage = {\n  getItem: name => {\n    initializeDefaultStorage(defaultStorage);\n    return defaultStorage.getItem(name);\n  },\n  setItem: (name, value) => {\n    initializeDefaultStorage(defaultStorage);\n    defaultStorage.setItem(name, value);\n  }\n};\nconst debounceMap = {};\nfunction PanelGroupWithForwardedRef({\n  autoSaveId = null,\n  children,\n  className: classNameFromProps = \"\",\n  direction,\n  forwardedRef,\n  id: idFromProps = null,\n  onLayout = null,\n  keyboardResizeBy = null,\n  storage = defaultStorage,\n  style: styleFromProps,\n  tagName: Type = \"div\",\n  ...rest\n}) {\n  const groupId = useUniqueId(idFromProps);\n  const panelGroupElementRef = useRef(null);\n  const [dragState, setDragState] = useState(null);\n  const [layout, setLayout] = useState([]);\n  const forceUpdate = useForceUpdate();\n  const panelIdToLastNotifiedSizeMapRef = useRef({});\n  const panelSizeBeforeCollapseRef = useRef(new Map());\n  const prevDeltaRef = useRef(0);\n  const committedValuesRef = useRef({\n    autoSaveId,\n    direction,\n    dragState,\n    id: groupId,\n    keyboardResizeBy,\n    onLayout,\n    storage\n  });\n  const eagerValuesRef = useRef({\n    layout,\n    panelDataArray: [],\n    panelDataArrayChanged: false\n  });\n  const devWarningsRef = useRef({\n    didLogIdAndOrderWarning: false,\n    didLogPanelConstraintsWarning: false,\n    prevPanelIds: []\n  });\n  useImperativeHandle(forwardedRef, () => ({\n    getId: () => committedValuesRef.current.id,\n    getLayout: () => {\n      const {\n        layout\n      } = eagerValuesRef.current;\n      return layout;\n    },\n    setLayout: unsafeLayout => {\n      const {\n        onLayout\n      } = committedValuesRef.current;\n      const {\n        layout: prevLayout,\n        panelDataArray\n      } = eagerValuesRef.current;\n      const safeLayout = validatePanelGroupLayout({\n        layout: unsafeLayout,\n        panelConstraints: panelDataArray.map(panelData => panelData.constraints)\n      });\n      if (!areEqual(prevLayout, safeLayout)) {\n        setLayout(safeLayout);\n        eagerValuesRef.current.layout = safeLayout;\n        if (onLayout) {\n          onLayout(safeLayout);\n        }\n        callPanelCallbacks(panelDataArray, safeLayout, panelIdToLastNotifiedSizeMapRef.current);\n      }\n    }\n  }), []);\n  useIsomorphicLayoutEffect(() => {\n    committedValuesRef.current.autoSaveId = autoSaveId;\n    committedValuesRef.current.direction = direction;\n    committedValuesRef.current.dragState = dragState;\n    committedValuesRef.current.id = groupId;\n    committedValuesRef.current.onLayout = onLayout;\n    committedValuesRef.current.storage = storage;\n  });\n  useWindowSplitterPanelGroupBehavior({\n    committedValuesRef,\n    eagerValuesRef,\n    groupId,\n    layout,\n    panelDataArray: eagerValuesRef.current.panelDataArray,\n    setLayout,\n    panelGroupElement: panelGroupElementRef.current\n  });\n  useEffect(() => {\n    const {\n      panelDataArray\n    } = eagerValuesRef.current;\n\n    // If this panel has been configured to persist sizing information, save sizes to local storage.\n    if (autoSaveId) {\n      if (layout.length === 0 || layout.length !== panelDataArray.length) {\n        return;\n      }\n      let debouncedSave = debounceMap[autoSaveId];\n\n      // Limit the frequency of localStorage updates.\n      if (debouncedSave == null) {\n        debouncedSave = debounce(savePanelGroupState, LOCAL_STORAGE_DEBOUNCE_INTERVAL);\n        debounceMap[autoSaveId] = debouncedSave;\n      }\n\n      // Clone mutable data before passing to the debounced function,\n      // else we run the risk of saving an incorrect combination of mutable and immutable values to state.\n      const clonedPanelDataArray = [...panelDataArray];\n      const clonedPanelSizesBeforeCollapse = new Map(panelSizeBeforeCollapseRef.current);\n      debouncedSave(autoSaveId, clonedPanelDataArray, clonedPanelSizesBeforeCollapse, layout, storage);\n    }\n  }, [autoSaveId, layout, storage]);\n\n  // DEV warnings\n  useEffect(() => {\n    {\n      const {\n        panelDataArray\n      } = eagerValuesRef.current;\n      const {\n        didLogIdAndOrderWarning,\n        didLogPanelConstraintsWarning,\n        prevPanelIds\n      } = devWarningsRef.current;\n      if (!didLogIdAndOrderWarning) {\n        const panelIds = panelDataArray.map(({\n          id\n        }) => id);\n        devWarningsRef.current.prevPanelIds = panelIds;\n        const panelsHaveChanged = prevPanelIds.length > 0 && !areEqual(prevPanelIds, panelIds);\n        if (panelsHaveChanged) {\n          if (panelDataArray.find(({\n            idIsFromProps,\n            order\n          }) => !idIsFromProps || order == null)) {\n            devWarningsRef.current.didLogIdAndOrderWarning = true;\n            console.warn(`WARNING: Panel id and order props recommended when panels are dynamically rendered`);\n          }\n        }\n      }\n      if (!didLogPanelConstraintsWarning) {\n        const panelConstraints = panelDataArray.map(panelData => panelData.constraints);\n        for (let panelIndex = 0; panelIndex < panelConstraints.length; panelIndex++) {\n          const panelData = panelDataArray[panelIndex];\n          assert(panelData, `Panel data not found for index ${panelIndex}`);\n          const isValid = validatePanelConstraints({\n            panelConstraints,\n            panelId: panelData.id,\n            panelIndex\n          });\n          if (!isValid) {\n            devWarningsRef.current.didLogPanelConstraintsWarning = true;\n            break;\n          }\n        }\n      }\n    }\n  });\n\n  // External APIs are safe to memoize via committed values ref\n  const collapsePanel = useCallback(panelData => {\n    const {\n      onLayout\n    } = committedValuesRef.current;\n    const {\n      layout: prevLayout,\n      panelDataArray\n    } = eagerValuesRef.current;\n    if (panelData.constraints.collapsible) {\n      const panelConstraintsArray = panelDataArray.map(panelData => panelData.constraints);\n      const {\n        collapsedSize = 0,\n        panelSize,\n        pivotIndices\n      } = panelDataHelper(panelDataArray, panelData, prevLayout);\n      assert(panelSize != null, `Panel size not found for panel \"${panelData.id}\"`);\n      if (!fuzzyNumbersEqual$1(panelSize, collapsedSize)) {\n        // Store size before collapse;\n        // This is the size that gets restored if the expand() API is used.\n        panelSizeBeforeCollapseRef.current.set(panelData.id, panelSize);\n        const isLastPanel = findPanelDataIndex(panelDataArray, panelData) === panelDataArray.length - 1;\n        const delta = isLastPanel ? panelSize - collapsedSize : collapsedSize - panelSize;\n        const nextLayout = adjustLayoutByDelta({\n          delta,\n          initialLayout: prevLayout,\n          panelConstraints: panelConstraintsArray,\n          pivotIndices,\n          prevLayout,\n          trigger: \"imperative-api\"\n        });\n        if (!compareLayouts(prevLayout, nextLayout)) {\n          setLayout(nextLayout);\n          eagerValuesRef.current.layout = nextLayout;\n          if (onLayout) {\n            onLayout(nextLayout);\n          }\n          callPanelCallbacks(panelDataArray, nextLayout, panelIdToLastNotifiedSizeMapRef.current);\n        }\n      }\n    }\n  }, []);\n\n  // External APIs are safe to memoize via committed values ref\n  const expandPanel = useCallback((panelData, minSizeOverride) => {\n    const {\n      onLayout\n    } = committedValuesRef.current;\n    const {\n      layout: prevLayout,\n      panelDataArray\n    } = eagerValuesRef.current;\n    if (panelData.constraints.collapsible) {\n      const panelConstraintsArray = panelDataArray.map(panelData => panelData.constraints);\n      const {\n        collapsedSize = 0,\n        panelSize = 0,\n        minSize: minSizeFromProps = 0,\n        pivotIndices\n      } = panelDataHelper(panelDataArray, panelData, prevLayout);\n      const minSize = minSizeOverride !== null && minSizeOverride !== void 0 ? minSizeOverride : minSizeFromProps;\n      if (fuzzyNumbersEqual$1(panelSize, collapsedSize)) {\n        // Restore this panel to the size it was before it was collapsed, if possible.\n        const prevPanelSize = panelSizeBeforeCollapseRef.current.get(panelData.id);\n        const baseSize = prevPanelSize != null && prevPanelSize >= minSize ? prevPanelSize : minSize;\n        const isLastPanel = findPanelDataIndex(panelDataArray, panelData) === panelDataArray.length - 1;\n        const delta = isLastPanel ? panelSize - baseSize : baseSize - panelSize;\n        const nextLayout = adjustLayoutByDelta({\n          delta,\n          initialLayout: prevLayout,\n          panelConstraints: panelConstraintsArray,\n          pivotIndices,\n          prevLayout,\n          trigger: \"imperative-api\"\n        });\n        if (!compareLayouts(prevLayout, nextLayout)) {\n          setLayout(nextLayout);\n          eagerValuesRef.current.layout = nextLayout;\n          if (onLayout) {\n            onLayout(nextLayout);\n          }\n          callPanelCallbacks(panelDataArray, nextLayout, panelIdToLastNotifiedSizeMapRef.current);\n        }\n      }\n    }\n  }, []);\n\n  // External APIs are safe to memoize via committed values ref\n  const getPanelSize = useCallback(panelData => {\n    const {\n      layout,\n      panelDataArray\n    } = eagerValuesRef.current;\n    const {\n      panelSize\n    } = panelDataHelper(panelDataArray, panelData, layout);\n    assert(panelSize != null, `Panel size not found for panel \"${panelData.id}\"`);\n    return panelSize;\n  }, []);\n\n  // This API should never read from committedValuesRef\n  const getPanelStyle = useCallback((panelData, defaultSize) => {\n    const {\n      panelDataArray\n    } = eagerValuesRef.current;\n    const panelIndex = findPanelDataIndex(panelDataArray, panelData);\n    return computePanelFlexBoxStyle({\n      defaultSize,\n      dragState,\n      layout,\n      panelData: panelDataArray,\n      panelIndex\n    });\n  }, [dragState, layout]);\n\n  // External APIs are safe to memoize via committed values ref\n  const isPanelCollapsed = useCallback(panelData => {\n    const {\n      layout,\n      panelDataArray\n    } = eagerValuesRef.current;\n    const {\n      collapsedSize = 0,\n      collapsible,\n      panelSize\n    } = panelDataHelper(panelDataArray, panelData, layout);\n    assert(panelSize != null, `Panel size not found for panel \"${panelData.id}\"`);\n    return collapsible === true && fuzzyNumbersEqual$1(panelSize, collapsedSize);\n  }, []);\n\n  // External APIs are safe to memoize via committed values ref\n  const isPanelExpanded = useCallback(panelData => {\n    const {\n      layout,\n      panelDataArray\n    } = eagerValuesRef.current;\n    const {\n      collapsedSize = 0,\n      collapsible,\n      panelSize\n    } = panelDataHelper(panelDataArray, panelData, layout);\n    assert(panelSize != null, `Panel size not found for panel \"${panelData.id}\"`);\n    return !collapsible || fuzzyCompareNumbers(panelSize, collapsedSize) > 0;\n  }, []);\n  const registerPanel = useCallback(panelData => {\n    const {\n      panelDataArray\n    } = eagerValuesRef.current;\n    panelDataArray.push(panelData);\n    panelDataArray.sort((panelA, panelB) => {\n      const orderA = panelA.order;\n      const orderB = panelB.order;\n      if (orderA == null && orderB == null) {\n        return 0;\n      } else if (orderA == null) {\n        return -1;\n      } else if (orderB == null) {\n        return 1;\n      } else {\n        return orderA - orderB;\n      }\n    });\n    eagerValuesRef.current.panelDataArrayChanged = true;\n    forceUpdate();\n  }, [forceUpdate]);\n\n  // (Re)calculate group layout whenever panels are registered or unregistered.\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  useIsomorphicLayoutEffect(() => {\n    if (eagerValuesRef.current.panelDataArrayChanged) {\n      eagerValuesRef.current.panelDataArrayChanged = false;\n      const {\n        autoSaveId,\n        onLayout,\n        storage\n      } = committedValuesRef.current;\n      const {\n        layout: prevLayout,\n        panelDataArray\n      } = eagerValuesRef.current;\n\n      // If this panel has been configured to persist sizing information,\n      // default size should be restored from local storage if possible.\n      let unsafeLayout = null;\n      if (autoSaveId) {\n        const state = loadPanelGroupState(autoSaveId, panelDataArray, storage);\n        if (state) {\n          panelSizeBeforeCollapseRef.current = new Map(Object.entries(state.expandToSizes));\n          unsafeLayout = state.layout;\n        }\n      }\n      if (unsafeLayout == null) {\n        unsafeLayout = calculateUnsafeDefaultLayout({\n          panelDataArray\n        });\n      }\n\n      // Validate even saved layouts in case something has changed since last render\n      // e.g. for pixel groups, this could be the size of the window\n      const nextLayout = validatePanelGroupLayout({\n        layout: unsafeLayout,\n        panelConstraints: panelDataArray.map(panelData => panelData.constraints)\n      });\n      if (!areEqual(prevLayout, nextLayout)) {\n        setLayout(nextLayout);\n        eagerValuesRef.current.layout = nextLayout;\n        if (onLayout) {\n          onLayout(nextLayout);\n        }\n        callPanelCallbacks(panelDataArray, nextLayout, panelIdToLastNotifiedSizeMapRef.current);\n      }\n    }\n  });\n\n  // Reset the cached layout if hidden by the Activity/Offscreen API\n  useIsomorphicLayoutEffect(() => {\n    const eagerValues = eagerValuesRef.current;\n    return () => {\n      eagerValues.layout = [];\n    };\n  }, []);\n  const registerResizeHandle = useCallback(dragHandleId => {\n    let isRTL = false;\n    const panelGroupElement = panelGroupElementRef.current;\n    if (panelGroupElement) {\n      const style = window.getComputedStyle(panelGroupElement, null);\n      if (style.getPropertyValue(\"direction\") === \"rtl\") {\n        isRTL = true;\n      }\n    }\n    return function resizeHandler(event) {\n      event.preventDefault();\n      const panelGroupElement = panelGroupElementRef.current;\n      if (!panelGroupElement) {\n        return () => null;\n      }\n      const {\n        direction,\n        dragState,\n        id: groupId,\n        keyboardResizeBy,\n        onLayout\n      } = committedValuesRef.current;\n      const {\n        layout: prevLayout,\n        panelDataArray\n      } = eagerValuesRef.current;\n      const {\n        initialLayout\n      } = dragState !== null && dragState !== void 0 ? dragState : {};\n      const pivotIndices = determinePivotIndices(groupId, dragHandleId, panelGroupElement);\n      let delta = calculateDeltaPercentage(event, dragHandleId, direction, dragState, keyboardResizeBy, panelGroupElement);\n      const isHorizontal = direction === \"horizontal\";\n      if (isHorizontal && isRTL) {\n        delta = -delta;\n      }\n      const panelConstraints = panelDataArray.map(panelData => panelData.constraints);\n      const nextLayout = adjustLayoutByDelta({\n        delta,\n        initialLayout: initialLayout !== null && initialLayout !== void 0 ? initialLayout : prevLayout,\n        panelConstraints,\n        pivotIndices,\n        prevLayout,\n        trigger: isKeyDown(event) ? \"keyboard\" : \"mouse-or-touch\"\n      });\n      const layoutChanged = !compareLayouts(prevLayout, nextLayout);\n\n      // Only update the cursor for layout changes triggered by touch/mouse events (not keyboard)\n      // Update the cursor even if the layout hasn't changed (we may need to show an invalid cursor state)\n      if (isPointerEvent(event) || isMouseEvent(event)) {\n        // Watch for multiple subsequent deltas; this might occur for tiny cursor movements.\n        // In this case, Panel sizes might not change–\n        // but updating cursor in this scenario would cause a flicker.\n        if (prevDeltaRef.current != delta) {\n          prevDeltaRef.current = delta;\n          if (!layoutChanged && delta !== 0) {\n            // If the pointer has moved too far to resize the panel any further, note this so we can update the cursor.\n            // This mimics VS Code behavior.\n            if (isHorizontal) {\n              reportConstraintsViolation(dragHandleId, delta < 0 ? EXCEEDED_HORIZONTAL_MIN : EXCEEDED_HORIZONTAL_MAX);\n            } else {\n              reportConstraintsViolation(dragHandleId, delta < 0 ? EXCEEDED_VERTICAL_MIN : EXCEEDED_VERTICAL_MAX);\n            }\n          } else {\n            reportConstraintsViolation(dragHandleId, 0);\n          }\n        }\n      }\n      if (layoutChanged) {\n        setLayout(nextLayout);\n        eagerValuesRef.current.layout = nextLayout;\n        if (onLayout) {\n          onLayout(nextLayout);\n        }\n        callPanelCallbacks(panelDataArray, nextLayout, panelIdToLastNotifiedSizeMapRef.current);\n      }\n    };\n  }, []);\n\n  // External APIs are safe to memoize via committed values ref\n  const resizePanel = useCallback((panelData, unsafePanelSize) => {\n    const {\n      onLayout\n    } = committedValuesRef.current;\n    const {\n      layout: prevLayout,\n      panelDataArray\n    } = eagerValuesRef.current;\n    const panelConstraintsArray = panelDataArray.map(panelData => panelData.constraints);\n    const {\n      panelSize,\n      pivotIndices\n    } = panelDataHelper(panelDataArray, panelData, prevLayout);\n    assert(panelSize != null, `Panel size not found for panel \"${panelData.id}\"`);\n    const isLastPanel = findPanelDataIndex(panelDataArray, panelData) === panelDataArray.length - 1;\n    const delta = isLastPanel ? panelSize - unsafePanelSize : unsafePanelSize - panelSize;\n    const nextLayout = adjustLayoutByDelta({\n      delta,\n      initialLayout: prevLayout,\n      panelConstraints: panelConstraintsArray,\n      pivotIndices,\n      prevLayout,\n      trigger: \"imperative-api\"\n    });\n    if (!compareLayouts(prevLayout, nextLayout)) {\n      setLayout(nextLayout);\n      eagerValuesRef.current.layout = nextLayout;\n      if (onLayout) {\n        onLayout(nextLayout);\n      }\n      callPanelCallbacks(panelDataArray, nextLayout, panelIdToLastNotifiedSizeMapRef.current);\n    }\n  }, []);\n  const reevaluatePanelConstraints = useCallback((panelData, prevConstraints) => {\n    const {\n      layout,\n      panelDataArray\n    } = eagerValuesRef.current;\n    const {\n      collapsedSize: prevCollapsedSize = 0,\n      collapsible: prevCollapsible\n    } = prevConstraints;\n    const {\n      collapsedSize: nextCollapsedSize = 0,\n      collapsible: nextCollapsible,\n      maxSize: nextMaxSize = 100,\n      minSize: nextMinSize = 0\n    } = panelData.constraints;\n    const {\n      panelSize: prevPanelSize\n    } = panelDataHelper(panelDataArray, panelData, layout);\n    if (prevPanelSize == null) {\n      // It's possible that the panels in this group have changed since the last render\n      return;\n    }\n    if (prevCollapsible && nextCollapsible && fuzzyNumbersEqual$1(prevPanelSize, prevCollapsedSize)) {\n      if (!fuzzyNumbersEqual$1(prevCollapsedSize, nextCollapsedSize)) {\n        resizePanel(panelData, nextCollapsedSize);\n      }\n    } else if (prevPanelSize < nextMinSize) {\n      resizePanel(panelData, nextMinSize);\n    } else if (prevPanelSize > nextMaxSize) {\n      resizePanel(panelData, nextMaxSize);\n    }\n  }, [resizePanel]);\n\n  // TODO Multiple drag handles can be active at the same time so this API is a bit awkward now\n  const startDragging = useCallback((dragHandleId, event) => {\n    const {\n      direction\n    } = committedValuesRef.current;\n    const {\n      layout\n    } = eagerValuesRef.current;\n    if (!panelGroupElementRef.current) {\n      return;\n    }\n    const handleElement = getResizeHandleElement(dragHandleId, panelGroupElementRef.current);\n    assert(handleElement, `Drag handle element not found for id \"${dragHandleId}\"`);\n    const initialCursorPosition = getResizeEventCursorPosition(direction, event);\n    setDragState({\n      dragHandleId,\n      dragHandleRect: handleElement.getBoundingClientRect(),\n      initialCursorPosition,\n      initialLayout: layout\n    });\n  }, []);\n  const stopDragging = useCallback(() => {\n    setDragState(null);\n  }, []);\n  const unregisterPanel = useCallback(panelData => {\n    const {\n      panelDataArray\n    } = eagerValuesRef.current;\n    const index = findPanelDataIndex(panelDataArray, panelData);\n    if (index >= 0) {\n      panelDataArray.splice(index, 1);\n\n      // TRICKY\n      // When a panel is removed from the group, we should delete the most recent prev-size entry for it.\n      // If we don't do this, then a conditionally rendered panel might not call onResize when it's re-mounted.\n      // Strict effects mode makes this tricky though because all panels will be registered, unregistered, then re-registered on mount.\n      delete panelIdToLastNotifiedSizeMapRef.current[panelData.id];\n      eagerValuesRef.current.panelDataArrayChanged = true;\n      forceUpdate();\n    }\n  }, [forceUpdate]);\n  const context = useMemo(() => ({\n    collapsePanel,\n    direction,\n    dragState,\n    expandPanel,\n    getPanelSize,\n    getPanelStyle,\n    groupId,\n    isPanelCollapsed,\n    isPanelExpanded,\n    reevaluatePanelConstraints,\n    registerPanel,\n    registerResizeHandle,\n    resizePanel,\n    startDragging,\n    stopDragging,\n    unregisterPanel,\n    panelGroupElement: panelGroupElementRef.current\n  }), [collapsePanel, dragState, direction, expandPanel, getPanelSize, getPanelStyle, groupId, isPanelCollapsed, isPanelExpanded, reevaluatePanelConstraints, registerPanel, registerResizeHandle, resizePanel, startDragging, stopDragging, unregisterPanel]);\n  const style = {\n    display: \"flex\",\n    flexDirection: direction === \"horizontal\" ? \"row\" : \"column\",\n    height: \"100%\",\n    overflow: \"hidden\",\n    width: \"100%\"\n  };\n  return createElement(PanelGroupContext.Provider, {\n    value: context\n  }, createElement(Type, {\n    ...rest,\n    children,\n    className: classNameFromProps,\n    id: idFromProps,\n    ref: panelGroupElementRef,\n    style: {\n      ...style,\n      ...styleFromProps\n    },\n    // CSS selectors\n    [DATA_ATTRIBUTES.group]: \"\",\n    [DATA_ATTRIBUTES.groupDirection]: direction,\n    [DATA_ATTRIBUTES.groupId]: groupId\n  }));\n}\nconst PanelGroup = forwardRef((props, ref) => createElement(PanelGroupWithForwardedRef, {\n  ...props,\n  forwardedRef: ref\n}));\nPanelGroupWithForwardedRef.displayName = \"PanelGroup\";\nPanelGroup.displayName = \"forwardRef(PanelGroup)\";\nfunction findPanelDataIndex(panelDataArray, panelData) {\n  return panelDataArray.findIndex(prevPanelData => prevPanelData === panelData || prevPanelData.id === panelData.id);\n}\nfunction panelDataHelper(panelDataArray, panelData, layout) {\n  const panelIndex = findPanelDataIndex(panelDataArray, panelData);\n  const isLastPanel = panelIndex === panelDataArray.length - 1;\n  const pivotIndices = isLastPanel ? [panelIndex - 1, panelIndex] : [panelIndex, panelIndex + 1];\n  const panelSize = layout[panelIndex];\n  return {\n    ...panelData.constraints,\n    panelSize,\n    pivotIndices\n  };\n}\n\n// https://www.w3.org/WAI/ARIA/apg/patterns/windowsplitter/\n\nfunction useWindowSplitterResizeHandlerBehavior({\n  disabled,\n  handleId,\n  resizeHandler,\n  panelGroupElement\n}) {\n  useEffect(() => {\n    if (disabled || resizeHandler == null || panelGroupElement == null) {\n      return;\n    }\n    const handleElement = getResizeHandleElement(handleId, panelGroupElement);\n    if (handleElement == null) {\n      return;\n    }\n    const onKeyDown = event => {\n      if (event.defaultPrevented) {\n        return;\n      }\n      switch (event.key) {\n        case \"ArrowDown\":\n        case \"ArrowLeft\":\n        case \"ArrowRight\":\n        case \"ArrowUp\":\n        case \"End\":\n        case \"Home\":\n          {\n            event.preventDefault();\n            resizeHandler(event);\n            break;\n          }\n        case \"F6\":\n          {\n            event.preventDefault();\n            const groupId = handleElement.getAttribute(DATA_ATTRIBUTES.groupId);\n            assert(groupId, `No group element found for id \"${groupId}\"`);\n            const handles = getResizeHandleElementsForGroup(groupId, panelGroupElement);\n            const index = getResizeHandleElementIndex(groupId, handleId, panelGroupElement);\n            assert(index !== null, `No resize element found for id \"${handleId}\"`);\n            const nextIndex = event.shiftKey ? index > 0 ? index - 1 : handles.length - 1 : index + 1 < handles.length ? index + 1 : 0;\n            const nextHandle = handles[nextIndex];\n            nextHandle.focus();\n            break;\n          }\n      }\n    };\n    handleElement.addEventListener(\"keydown\", onKeyDown);\n    return () => {\n      handleElement.removeEventListener(\"keydown\", onKeyDown);\n    };\n  }, [panelGroupElement, disabled, handleId, resizeHandler]);\n}\nfunction PanelResizeHandle({\n  children = null,\n  className: classNameFromProps = \"\",\n  disabled = false,\n  hitAreaMargins,\n  id: idFromProps,\n  onBlur,\n  onClick,\n  onDragging,\n  onFocus,\n  onPointerDown,\n  onPointerUp,\n  style: styleFromProps = {},\n  tabIndex = 0,\n  tagName: Type = \"div\",\n  ...rest\n}) {\n  var _hitAreaMargins$coars, _hitAreaMargins$fine;\n  const elementRef = useRef(null);\n\n  // Use a ref to guard against users passing inline props\n  const callbacksRef = useRef({\n    onClick,\n    onDragging,\n    onPointerDown,\n    onPointerUp\n  });\n  useEffect(() => {\n    callbacksRef.current.onClick = onClick;\n    callbacksRef.current.onDragging = onDragging;\n    callbacksRef.current.onPointerDown = onPointerDown;\n    callbacksRef.current.onPointerUp = onPointerUp;\n  });\n  const panelGroupContext = useContext(PanelGroupContext);\n  if (panelGroupContext === null) {\n    throw Error(`PanelResizeHandle components must be rendered within a PanelGroup container`);\n  }\n  const {\n    direction,\n    groupId,\n    registerResizeHandle: registerResizeHandleWithParentGroup,\n    startDragging,\n    stopDragging,\n    panelGroupElement\n  } = panelGroupContext;\n  const resizeHandleId = useUniqueId(idFromProps);\n  const [state, setState] = useState(\"inactive\");\n  const [isFocused, setIsFocused] = useState(false);\n  const [resizeHandler, setResizeHandler] = useState(null);\n  const committedValuesRef = useRef({\n    state\n  });\n  useIsomorphicLayoutEffect(() => {\n    committedValuesRef.current.state = state;\n  });\n  useEffect(() => {\n    if (disabled) {\n      setResizeHandler(null);\n    } else {\n      const resizeHandler = registerResizeHandleWithParentGroup(resizeHandleId);\n      setResizeHandler(() => resizeHandler);\n    }\n  }, [disabled, resizeHandleId, registerResizeHandleWithParentGroup]);\n\n  // Extract hit area margins before passing them to the effect's dependency array\n  // so that inline object values won't trigger re-renders\n  const coarseHitAreaMargins = (_hitAreaMargins$coars = hitAreaMargins === null || hitAreaMargins === void 0 ? void 0 : hitAreaMargins.coarse) !== null && _hitAreaMargins$coars !== void 0 ? _hitAreaMargins$coars : 15;\n  const fineHitAreaMargins = (_hitAreaMargins$fine = hitAreaMargins === null || hitAreaMargins === void 0 ? void 0 : hitAreaMargins.fine) !== null && _hitAreaMargins$fine !== void 0 ? _hitAreaMargins$fine : 5;\n  useEffect(() => {\n    if (disabled || resizeHandler == null) {\n      return;\n    }\n    const element = elementRef.current;\n    assert(element, \"Element ref not attached\");\n    let didMove = false;\n    const setResizeHandlerState = (action, isActive, event) => {\n      if (!isActive) {\n        setState(\"inactive\");\n        return;\n      }\n      switch (action) {\n        case \"down\":\n          {\n            setState(\"drag\");\n            didMove = false;\n            assert(event, 'Expected event to be defined for \"down\" action');\n            startDragging(resizeHandleId, event);\n            const {\n              onDragging,\n              onPointerDown\n            } = callbacksRef.current;\n            onDragging === null || onDragging === void 0 ? void 0 : onDragging(true);\n            onPointerDown === null || onPointerDown === void 0 ? void 0 : onPointerDown();\n            break;\n          }\n        case \"move\":\n          {\n            const {\n              state\n            } = committedValuesRef.current;\n            didMove = true;\n            if (state !== \"drag\") {\n              setState(\"hover\");\n            }\n            assert(event, 'Expected event to be defined for \"move\" action');\n            resizeHandler(event);\n            break;\n          }\n        case \"up\":\n          {\n            setState(\"hover\");\n            stopDragging();\n            const {\n              onClick,\n              onDragging,\n              onPointerUp\n            } = callbacksRef.current;\n            onDragging === null || onDragging === void 0 ? void 0 : onDragging(false);\n            onPointerUp === null || onPointerUp === void 0 ? void 0 : onPointerUp();\n            if (!didMove) {\n              onClick === null || onClick === void 0 ? void 0 : onClick();\n            }\n            break;\n          }\n      }\n    };\n    return registerResizeHandle(resizeHandleId, element, direction, {\n      coarse: coarseHitAreaMargins,\n      fine: fineHitAreaMargins\n    }, setResizeHandlerState);\n  }, [coarseHitAreaMargins, direction, disabled, fineHitAreaMargins, registerResizeHandleWithParentGroup, resizeHandleId, resizeHandler, startDragging, stopDragging]);\n  useWindowSplitterResizeHandlerBehavior({\n    disabled,\n    handleId: resizeHandleId,\n    resizeHandler,\n    panelGroupElement\n  });\n  const style = {\n    touchAction: \"none\",\n    userSelect: \"none\"\n  };\n  return createElement(Type, {\n    ...rest,\n    children,\n    className: classNameFromProps,\n    id: idFromProps,\n    onBlur: () => {\n      setIsFocused(false);\n      onBlur === null || onBlur === void 0 ? void 0 : onBlur();\n    },\n    onFocus: () => {\n      setIsFocused(true);\n      onFocus === null || onFocus === void 0 ? void 0 : onFocus();\n    },\n    ref: elementRef,\n    role: \"separator\",\n    style: {\n      ...style,\n      ...styleFromProps\n    },\n    tabIndex,\n    // CSS selectors\n    [DATA_ATTRIBUTES.groupDirection]: direction,\n    [DATA_ATTRIBUTES.groupId]: groupId,\n    [DATA_ATTRIBUTES.resizeHandle]: \"\",\n    [DATA_ATTRIBUTES.resizeHandleActive]: state === \"drag\" ? \"pointer\" : isFocused ? \"keyboard\" : undefined,\n    [DATA_ATTRIBUTES.resizeHandleEnabled]: !disabled,\n    [DATA_ATTRIBUTES.resizeHandleId]: resizeHandleId,\n    [DATA_ATTRIBUTES.resizeHandleState]: state\n  });\n}\nPanelResizeHandle.displayName = \"PanelResizeHandle\";\nfunction usePanelGroupContext() {\n  const context = useContext(PanelGroupContext);\n  return {\n    direction: context === null || context === void 0 ? void 0 : context.direction,\n    groupId: context === null || context === void 0 ? void 0 : context.groupId\n  };\n}\nfunction getPanelElement(id, scope = document) {\n  const element = scope.querySelector(`[data-panel-id=\"${id}\"]`);\n  if (element) {\n    return element;\n  }\n  return null;\n}\nfunction getPanelElementsForGroup(groupId, scope = document) {\n  return Array.from(scope.querySelectorAll(`[data-panel][data-panel-group-id=\"${groupId}\"]`));\n}\nfunction getIntersectingRectangle(rectOne, rectTwo, strict) {\n  if (!intersects(rectOne, rectTwo, strict)) {\n    return {\n      x: 0,\n      y: 0,\n      width: 0,\n      height: 0\n    };\n  }\n  return {\n    x: Math.max(rectOne.x, rectTwo.x),\n    y: Math.max(rectOne.y, rectTwo.y),\n    width: Math.min(rectOne.x + rectOne.width, rectTwo.x + rectTwo.width) - Math.max(rectOne.x, rectTwo.x),\n    height: Math.min(rectOne.y + rectOne.height, rectTwo.y + rectTwo.height) - Math.max(rectOne.y, rectTwo.y)\n  };\n}\nexport { DATA_ATTRIBUTES, Panel, PanelGroup, PanelResizeHandle, assert, disableGlobalCursorStyles, enableGlobalCursorStyles, getIntersectingRectangle, getPanelElement, getPanelElementsForGroup, getPanelGroupElement, getResizeHandleElement, getResizeHandleElementIndex, getResizeHandleElementsForGroup, getResizeHandlePanelIds, intersects, setNonce, usePanelGroupContext };","map":{"version":3,"names":["React","createContext","useLayoutEffect","useRef","forwardRef","createElement","useContext","useImperativeHandle","useState","useCallback","useEffect","useMemo","PanelGroupContext","displayName","DATA_ATTRIBUTES","group","groupDirection","groupId","panel","panelCollapsible","panelId","panelSize","resizeHandle","resizeHandleActive","resizeHandleEnabled","resizeHandleId","resizeHandleState","PRECISION","useIsomorphicLayoutEffect","useId","toString","wrappedUseId","counter","useUniqueId","idFromParams","idFromUseId","idRef","current","PanelWithForwardedRef","children","className","classNameFromProps","collapsedSize","collapsible","defaultSize","forwardedRef","id","idFromProps","maxSize","minSize","onCollapse","onExpand","onResize","order","style","styleFromProps","tagName","Type","rest","context","Error","collapsePanel","expandPanel","getPanelSize","getPanelStyle","isPanelCollapsed","reevaluatePanelConstraints","registerPanel","resizePanel","unregisterPanel","panelDataRef","callbacks","constraints","idIsFromProps","undefined","devWarningsRef","didLogMissingDefaultSizeWarning","prevConstraints","panelData","collapse","expand","getId","getSize","isCollapsed","isExpanded","resize","size","parseFloat","flexGrow","toFixed","Panel","props","ref","nonce","getNonce","setNonce","value","currentCursorStyle","enabled","prevRuleIndex","styleElement","disableGlobalCursorStyles","enableGlobalCursorStyles","getCursorStyle","state","constraintFlags","horizontalMin","EXCEEDED_HORIZONTAL_MIN","horizontalMax","EXCEEDED_HORIZONTAL_MAX","verticalMin","EXCEEDED_VERTICAL_MIN","verticalMax","EXCEEDED_VERTICAL_MAX","resetGlobalCursorStyle","document","head","removeChild","setGlobalCursorStyle","_styleElement$sheet$i","_styleElement$sheet2","setAttribute","appendChild","_styleElement$sheet","sheet","removeRule","insertRule","isKeyDown","event","type","isPointerEvent","startsWith","isMouseEvent","getResizeEventCoordinates","isPrimary","x","clientX","y","clientY","Infinity","getInputType","matchMedia","matches","intersects","rectOne","rectTwo","strict","width","height","compare","a","b","ancestors","get_ancestors","common_ancestor","at","pop","assert","z_indexes","get_z_index","find_stacking_context","childNodes","furthest_ancestors","i","length","child","Math","sign","is_flex_item","node","_get_parent","display","getComputedStyle","get_parent","creates_stacking_context","position","zIndex","opacity","transform","webkitTransform","mixBlendMode","filter","webkitFilter","isolation","test","willChange","webkitOverflowScrolling","nodes","Number","push","parentNode","ShadowRoot","host","isCoarsePointer","intersectingHandles","isPointerDown","ownerDocumentCounts","Map","panelConstraintFlags","registeredResizeHandlers","Set","registerResizeHandle","element","direction","hitAreaMargins","setResizeHandlerState","_ownerDocumentCounts$","ownerDocument","data","count","get","set","add","updateListeners","unregisterResizeHandle","_ownerDocumentCounts$2","delete","includes","index","indexOf","splice","updateCursor","handlePointerDown","target","recalculateIntersectingHandles","updateResizeHandlerStates","preventDefault","isWithinResizeHandle","stopImmediatePropagation","handlePointerMove","buttons","handlePointerUp","clear","currentElement","hasAttribute","parentElement","targetElement","HTMLElement","SVGElement","forEach","dragHandleElement","dragHandleRect","getBoundingClientRect","bottom","left","right","top","margin","coarse","fine","eventIntersects","contains","didIntersect","reportConstraintsViolation","flag","intersectsHorizontal","intersectsVertical","listenersAbortController","_listenersAbortContro","abort","AbortController","options","capture","signal","body","addEventListener","_","action","isActive","useForceUpdate","setCount","prevCount","expectedCondition","message","console","error","fuzzyCompareNumbers","actual","expected","fractionDigits","fuzzyNumbersEqual$1","fuzzyNumbersEqual","fuzzyLayoutsEqual","actualSize","expectedSize","panelConstraints","panelConstraintsArray","panelIndex","halfwayPoint","min","adjustLayoutByDelta","delta","initialLayout","pivotIndices","prevLayout","trigger","nextLayout","firstPivotIndex","secondPivotIndex","deltaApplied","prevSize","localDelta","abs","increment","maxAvailableDelta","maxSafeSize","minAbsDelta","pivotIndex","deltaRemaining","unsafeSize","safeSize","toPrecision","localeCompare","numeric","totalSize","reduce","total","calculateAriaValues","layout","panelsArray","currentMinSize","currentMaxSize","totalMinSize","totalMaxSize","firstIndex","valueMax","valueMin","max","valueNow","getResizeHandleElementsForGroup","scope","Array","from","querySelectorAll","getResizeHandleElementIndex","handles","findIndex","handle","getAttribute","determinePivotIndices","dragHandleId","panelGroupElement","isHTMLElement","getPanelGroupElement","rootElement","dataset","panelGroupId","querySelector","getResizeHandleElement","getResizeHandlePanelIds","handleId","_panelsArray$index$id","_panelsArray$index","_panelsArray$id","_panelsArray","idBefore","idAfter","useWindowSplitterPanelGroupBehavior","committedValuesRef","eagerValuesRef","panelDataArray","setLayout","didWarnAboutMissingResizeHandle","resizeHandleElements","resizeHandleElement","warn","round","removeAttribute","eagerValues","groupElement","cleanupFunctions","map","onKeyDown","defaultPrevented","key","removeEventListener","cleanupFunction","areEqual","arrayA","arrayB","getResizeEventCursorPosition","isHorizontal","calculateDragOffsetPercentage","initialDragState","handleElement","initialCursorPosition","cursorPosition","groupRect","groupSizeInPixels","offsetPixels","offsetPercentage","calculateDeltaPercentage","keyboardResizeBy","shiftKey","movement","calculateUnsafeDefaultLayout","numPanelsWithSizes","remainingSize","numRemainingPanels","callPanelCallbacks","panelIdToLastNotifiedSizeMap","lastNotifiedSize","compareLayouts","computePanelFlexBoxStyle","dragState","precision","flexBasis","flexShrink","overflow","pointerEvents","debounce","callback","durationMs","timeoutId","callable","args","clearTimeout","setTimeout","initializeDefaultStorage","storageObject","localStorage","getItem","name","setItem","getPanelGroupKey","autoSaveId","getPanelKey","panels","JSON","stringify","sort","join","loadSerializedPanelGroupState","storage","panelGroupKey","serialized","parsed","parse","loadPanelGroupState","_loadSerializedPanelG","_state$panelKey","panelKey","savePanelGroupState","panelSizesBeforeCollapse","sizes","_loadSerializedPanelG2","expandToSizes","Object","fromEntries","entries","validatePanelConstraints","warnings","validatePanelGroupLayout","nextLayoutTotalSize","accumulated","LOCAL_STORAGE_DEBOUNCE_INTERVAL","defaultStorage","debounceMap","PanelGroupWithForwardedRef","onLayout","panelGroupElementRef","setDragState","forceUpdate","panelIdToLastNotifiedSizeMapRef","panelSizeBeforeCollapseRef","prevDeltaRef","panelDataArrayChanged","didLogIdAndOrderWarning","didLogPanelConstraintsWarning","prevPanelIds","getLayout","unsafeLayout","safeLayout","debouncedSave","clonedPanelDataArray","clonedPanelSizesBeforeCollapse","panelIds","panelsHaveChanged","find","isValid","panelDataHelper","isLastPanel","findPanelDataIndex","minSizeOverride","minSizeFromProps","prevPanelSize","baseSize","isPanelExpanded","panelA","panelB","orderA","orderB","isRTL","window","getPropertyValue","resizeHandler","layoutChanged","unsafePanelSize","prevCollapsedSize","prevCollapsible","nextCollapsedSize","nextCollapsible","nextMaxSize","nextMinSize","startDragging","stopDragging","flexDirection","Provider","PanelGroup","prevPanelData","useWindowSplitterResizeHandlerBehavior","disabled","nextIndex","nextHandle","focus","PanelResizeHandle","onBlur","onClick","onDragging","onFocus","onPointerDown","onPointerUp","tabIndex","_hitAreaMargins$coars","_hitAreaMargins$fine","elementRef","callbacksRef","panelGroupContext","registerResizeHandleWithParentGroup","setState","isFocused","setIsFocused","setResizeHandler","coarseHitAreaMargins","fineHitAreaMargins","didMove","touchAction","userSelect","role","usePanelGroupContext","getPanelElement","getPanelElementsForGroup","getIntersectingRectangle"],"sources":["C:/company_dashboard/node_modules/react-resizable-panels/dist/react-resizable-panels.browser.development.js"],"sourcesContent":["import * as React from 'react';\nimport { createContext, useLayoutEffect, useRef, forwardRef, createElement, useContext, useImperativeHandle, useState, useCallback, useEffect, useMemo } from 'react';\n\n// The \"contextmenu\" event is not supported as a PointerEvent in all browsers yet, so MouseEvent still need to be handled\n\nconst PanelGroupContext = createContext(null);\nPanelGroupContext.displayName = \"PanelGroupContext\";\n\nconst DATA_ATTRIBUTES = {\n  group: \"data-panel-group\",\n  groupDirection: \"data-panel-group-direction\",\n  groupId: \"data-panel-group-id\",\n  panel: \"data-panel\",\n  panelCollapsible: \"data-panel-collapsible\",\n  panelId: \"data-panel-id\",\n  panelSize: \"data-panel-size\",\n  resizeHandle: \"data-resize-handle\",\n  resizeHandleActive: \"data-resize-handle-active\",\n  resizeHandleEnabled: \"data-panel-resize-handle-enabled\",\n  resizeHandleId: \"data-panel-resize-handle-id\",\n  resizeHandleState: \"data-resize-handle-state\"\n};\nconst PRECISION = 10;\n\nconst useIsomorphicLayoutEffect = useLayoutEffect ;\n\nconst useId = React[\"useId\".toString()];\nconst wrappedUseId = typeof useId === \"function\" ? useId : () => null;\nlet counter = 0;\nfunction useUniqueId(idFromParams = null) {\n  const idFromUseId = wrappedUseId();\n  const idRef = useRef(idFromParams || idFromUseId || null);\n  if (idRef.current === null) {\n    idRef.current = \"\" + counter++;\n  }\n  return idFromParams !== null && idFromParams !== void 0 ? idFromParams : idRef.current;\n}\n\nfunction PanelWithForwardedRef({\n  children,\n  className: classNameFromProps = \"\",\n  collapsedSize,\n  collapsible,\n  defaultSize,\n  forwardedRef,\n  id: idFromProps,\n  maxSize,\n  minSize,\n  onCollapse,\n  onExpand,\n  onResize,\n  order,\n  style: styleFromProps,\n  tagName: Type = \"div\",\n  ...rest\n}) {\n  const context = useContext(PanelGroupContext);\n  if (context === null) {\n    throw Error(`Panel components must be rendered within a PanelGroup container`);\n  }\n  const {\n    collapsePanel,\n    expandPanel,\n    getPanelSize,\n    getPanelStyle,\n    groupId,\n    isPanelCollapsed,\n    reevaluatePanelConstraints,\n    registerPanel,\n    resizePanel,\n    unregisterPanel\n  } = context;\n  const panelId = useUniqueId(idFromProps);\n  const panelDataRef = useRef({\n    callbacks: {\n      onCollapse,\n      onExpand,\n      onResize\n    },\n    constraints: {\n      collapsedSize,\n      collapsible,\n      defaultSize,\n      maxSize,\n      minSize\n    },\n    id: panelId,\n    idIsFromProps: idFromProps !== undefined,\n    order\n  });\n  const devWarningsRef = useRef({\n    didLogMissingDefaultSizeWarning: false\n  });\n\n  // Normally we wouldn't log a warning during render,\n  // but effects don't run on the server, so we can't do it there\n  {\n    if (!devWarningsRef.current.didLogMissingDefaultSizeWarning) ;\n  }\n  useIsomorphicLayoutEffect(() => {\n    const {\n      callbacks,\n      constraints\n    } = panelDataRef.current;\n    const prevConstraints = {\n      ...constraints\n    };\n    panelDataRef.current.id = panelId;\n    panelDataRef.current.idIsFromProps = idFromProps !== undefined;\n    panelDataRef.current.order = order;\n    callbacks.onCollapse = onCollapse;\n    callbacks.onExpand = onExpand;\n    callbacks.onResize = onResize;\n    constraints.collapsedSize = collapsedSize;\n    constraints.collapsible = collapsible;\n    constraints.defaultSize = defaultSize;\n    constraints.maxSize = maxSize;\n    constraints.minSize = minSize;\n\n    // If constraints have changed, we should revisit panel sizes.\n    // This is uncommon but may happen if people are trying to implement pixel based constraints.\n    if (prevConstraints.collapsedSize !== constraints.collapsedSize || prevConstraints.collapsible !== constraints.collapsible || prevConstraints.maxSize !== constraints.maxSize || prevConstraints.minSize !== constraints.minSize) {\n      reevaluatePanelConstraints(panelDataRef.current, prevConstraints);\n    }\n  });\n  useIsomorphicLayoutEffect(() => {\n    const panelData = panelDataRef.current;\n    registerPanel(panelData);\n    return () => {\n      unregisterPanel(panelData);\n    };\n  }, [order, panelId, registerPanel, unregisterPanel]);\n  useImperativeHandle(forwardedRef, () => ({\n    collapse: () => {\n      collapsePanel(panelDataRef.current);\n    },\n    expand: minSize => {\n      expandPanel(panelDataRef.current, minSize);\n    },\n    getId() {\n      return panelId;\n    },\n    getSize() {\n      return getPanelSize(panelDataRef.current);\n    },\n    isCollapsed() {\n      return isPanelCollapsed(panelDataRef.current);\n    },\n    isExpanded() {\n      return !isPanelCollapsed(panelDataRef.current);\n    },\n    resize: size => {\n      resizePanel(panelDataRef.current, size);\n    }\n  }), [collapsePanel, expandPanel, getPanelSize, isPanelCollapsed, panelId, resizePanel]);\n  const style = getPanelStyle(panelDataRef.current, defaultSize);\n  return createElement(Type, {\n    ...rest,\n    children,\n    className: classNameFromProps,\n    id: panelId,\n    style: {\n      ...style,\n      ...styleFromProps\n    },\n    // CSS selectors\n    [DATA_ATTRIBUTES.groupId]: groupId,\n    [DATA_ATTRIBUTES.panel]: \"\",\n    [DATA_ATTRIBUTES.panelCollapsible]: collapsible || undefined,\n    [DATA_ATTRIBUTES.panelId]: panelId,\n    [DATA_ATTRIBUTES.panelSize]: parseFloat(\"\" + style.flexGrow).toFixed(1)\n  });\n}\nconst Panel = forwardRef((props, ref) => createElement(PanelWithForwardedRef, {\n  ...props,\n  forwardedRef: ref\n}));\nPanelWithForwardedRef.displayName = \"Panel\";\nPanel.displayName = \"forwardRef(Panel)\";\n\nlet nonce;\nfunction getNonce() {\n  return nonce;\n}\nfunction setNonce(value) {\n  nonce = value;\n}\n\nlet currentCursorStyle = null;\nlet enabled = true;\nlet prevRuleIndex = -1;\nlet styleElement = null;\nfunction disableGlobalCursorStyles() {\n  enabled = false;\n}\nfunction enableGlobalCursorStyles() {\n  enabled = true;\n}\nfunction getCursorStyle(state, constraintFlags) {\n  if (constraintFlags) {\n    const horizontalMin = (constraintFlags & EXCEEDED_HORIZONTAL_MIN) !== 0;\n    const horizontalMax = (constraintFlags & EXCEEDED_HORIZONTAL_MAX) !== 0;\n    const verticalMin = (constraintFlags & EXCEEDED_VERTICAL_MIN) !== 0;\n    const verticalMax = (constraintFlags & EXCEEDED_VERTICAL_MAX) !== 0;\n    if (horizontalMin) {\n      if (verticalMin) {\n        return \"se-resize\";\n      } else if (verticalMax) {\n        return \"ne-resize\";\n      } else {\n        return \"e-resize\";\n      }\n    } else if (horizontalMax) {\n      if (verticalMin) {\n        return \"sw-resize\";\n      } else if (verticalMax) {\n        return \"nw-resize\";\n      } else {\n        return \"w-resize\";\n      }\n    } else if (verticalMin) {\n      return \"s-resize\";\n    } else if (verticalMax) {\n      return \"n-resize\";\n    }\n  }\n  switch (state) {\n    case \"horizontal\":\n      return \"ew-resize\";\n    case \"intersection\":\n      return \"move\";\n    case \"vertical\":\n      return \"ns-resize\";\n  }\n}\nfunction resetGlobalCursorStyle() {\n  if (styleElement !== null) {\n    document.head.removeChild(styleElement);\n    currentCursorStyle = null;\n    styleElement = null;\n    prevRuleIndex = -1;\n  }\n}\nfunction setGlobalCursorStyle(state, constraintFlags) {\n  var _styleElement$sheet$i, _styleElement$sheet2;\n  if (!enabled) {\n    return;\n  }\n  const style = getCursorStyle(state, constraintFlags);\n  if (currentCursorStyle === style) {\n    return;\n  }\n  currentCursorStyle = style;\n  if (styleElement === null) {\n    styleElement = document.createElement(\"style\");\n    const nonce = getNonce();\n    if (nonce) {\n      styleElement.setAttribute(\"nonce\", nonce);\n    }\n    document.head.appendChild(styleElement);\n  }\n  if (prevRuleIndex >= 0) {\n    var _styleElement$sheet;\n    (_styleElement$sheet = styleElement.sheet) === null || _styleElement$sheet === void 0 ? void 0 : _styleElement$sheet.removeRule(prevRuleIndex);\n  }\n  prevRuleIndex = (_styleElement$sheet$i = (_styleElement$sheet2 = styleElement.sheet) === null || _styleElement$sheet2 === void 0 ? void 0 : _styleElement$sheet2.insertRule(`*{cursor: ${style} !important;}`)) !== null && _styleElement$sheet$i !== void 0 ? _styleElement$sheet$i : -1;\n}\n\nfunction isKeyDown(event) {\n  return event.type === \"keydown\";\n}\nfunction isPointerEvent(event) {\n  return event.type.startsWith(\"pointer\");\n}\nfunction isMouseEvent(event) {\n  return event.type.startsWith(\"mouse\");\n}\n\nfunction getResizeEventCoordinates(event) {\n  if (isPointerEvent(event)) {\n    if (event.isPrimary) {\n      return {\n        x: event.clientX,\n        y: event.clientY\n      };\n    }\n  } else if (isMouseEvent(event)) {\n    return {\n      x: event.clientX,\n      y: event.clientY\n    };\n  }\n  return {\n    x: Infinity,\n    y: Infinity\n  };\n}\n\nfunction getInputType() {\n  if (typeof matchMedia === \"function\") {\n    return matchMedia(\"(pointer:coarse)\").matches ? \"coarse\" : \"fine\";\n  }\n}\n\nfunction intersects(rectOne, rectTwo, strict) {\n  if (strict) {\n    return rectOne.x < rectTwo.x + rectTwo.width && rectOne.x + rectOne.width > rectTwo.x && rectOne.y < rectTwo.y + rectTwo.height && rectOne.y + rectOne.height > rectTwo.y;\n  } else {\n    return rectOne.x <= rectTwo.x + rectTwo.width && rectOne.x + rectOne.width >= rectTwo.x && rectOne.y <= rectTwo.y + rectTwo.height && rectOne.y + rectOne.height >= rectTwo.y;\n  }\n}\n\n// Forked from NPM stacking-order@2.0.0\n\n/**\n * Determine which of two nodes appears in front of the other —\n * if `a` is in front, returns 1, otherwise returns -1\n * @param {HTMLElement | SVGElement} a\n * @param {HTMLElement | SVGElement} b\n */\nfunction compare(a, b) {\n  if (a === b) throw new Error(\"Cannot compare node with itself\");\n  const ancestors = {\n    a: get_ancestors(a),\n    b: get_ancestors(b)\n  };\n  let common_ancestor;\n\n  // remove shared ancestors\n  while (ancestors.a.at(-1) === ancestors.b.at(-1)) {\n    a = ancestors.a.pop();\n    b = ancestors.b.pop();\n    common_ancestor = a;\n  }\n  assert(common_ancestor, \"Stacking order can only be calculated for elements with a common ancestor\");\n  const z_indexes = {\n    a: get_z_index(find_stacking_context(ancestors.a)),\n    b: get_z_index(find_stacking_context(ancestors.b))\n  };\n  if (z_indexes.a === z_indexes.b) {\n    const children = common_ancestor.childNodes;\n    const furthest_ancestors = {\n      a: ancestors.a.at(-1),\n      b: ancestors.b.at(-1)\n    };\n    let i = children.length;\n    while (i--) {\n      const child = children[i];\n      if (child === furthest_ancestors.a) return 1;\n      if (child === furthest_ancestors.b) return -1;\n    }\n  }\n  return Math.sign(z_indexes.a - z_indexes.b);\n}\nconst props = /\\b(?:position|zIndex|opacity|transform|webkitTransform|mixBlendMode|filter|webkitFilter|isolation)\\b/;\n\n/** @param {HTMLElement | SVGElement} node */\nfunction is_flex_item(node) {\n  var _get_parent;\n  // @ts-ignore\n  const display = getComputedStyle((_get_parent = get_parent(node)) !== null && _get_parent !== void 0 ? _get_parent : node).display;\n  return display === \"flex\" || display === \"inline-flex\";\n}\n\n/** @param {HTMLElement | SVGElement} node */\nfunction creates_stacking_context(node) {\n  const style = getComputedStyle(node);\n\n  // https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Positioning/Understanding_z_index/The_stacking_context\n  if (style.position === \"fixed\") return true;\n  // Forked to fix upstream bug https://github.com/Rich-Harris/stacking-order/issues/3\n  // if (\n  //   (style.zIndex !== \"auto\" && style.position !== \"static\") ||\n  //   is_flex_item(node)\n  // )\n  if (style.zIndex !== \"auto\" && (style.position !== \"static\" || is_flex_item(node))) return true;\n  if (+style.opacity < 1) return true;\n  if (\"transform\" in style && style.transform !== \"none\") return true;\n  if (\"webkitTransform\" in style && style.webkitTransform !== \"none\") return true;\n  if (\"mixBlendMode\" in style && style.mixBlendMode !== \"normal\") return true;\n  if (\"filter\" in style && style.filter !== \"none\") return true;\n  if (\"webkitFilter\" in style && style.webkitFilter !== \"none\") return true;\n  if (\"isolation\" in style && style.isolation === \"isolate\") return true;\n  if (props.test(style.willChange)) return true;\n  // @ts-expect-error\n  if (style.webkitOverflowScrolling === \"touch\") return true;\n  return false;\n}\n\n/** @param {(HTMLElement| SVGElement)[]} nodes */\nfunction find_stacking_context(nodes) {\n  let i = nodes.length;\n  while (i--) {\n    const node = nodes[i];\n    assert(node, \"Missing node\");\n    if (creates_stacking_context(node)) return node;\n  }\n  return null;\n}\n\n/** @param {HTMLElement | SVGElement} node */\nfunction get_z_index(node) {\n  return node && Number(getComputedStyle(node).zIndex) || 0;\n}\n\n/** @param {HTMLElement} node */\nfunction get_ancestors(node) {\n  const ancestors = [];\n  while (node) {\n    ancestors.push(node);\n    // @ts-ignore\n    node = get_parent(node);\n  }\n  return ancestors; // [ node, ... <body>, <html>, document ]\n}\n\n/** @param {HTMLElement} node */\nfunction get_parent(node) {\n  const {\n    parentNode\n  } = node;\n  if (parentNode && parentNode instanceof ShadowRoot) {\n    return parentNode.host;\n  }\n  return parentNode;\n}\n\nconst EXCEEDED_HORIZONTAL_MIN = 0b0001;\nconst EXCEEDED_HORIZONTAL_MAX = 0b0010;\nconst EXCEEDED_VERTICAL_MIN = 0b0100;\nconst EXCEEDED_VERTICAL_MAX = 0b1000;\nconst isCoarsePointer = getInputType() === \"coarse\";\nlet intersectingHandles = [];\nlet isPointerDown = false;\nlet ownerDocumentCounts = new Map();\nlet panelConstraintFlags = new Map();\nconst registeredResizeHandlers = new Set();\nfunction registerResizeHandle(resizeHandleId, element, direction, hitAreaMargins, setResizeHandlerState) {\n  var _ownerDocumentCounts$;\n  const {\n    ownerDocument\n  } = element;\n  const data = {\n    direction,\n    element,\n    hitAreaMargins,\n    setResizeHandlerState\n  };\n  const count = (_ownerDocumentCounts$ = ownerDocumentCounts.get(ownerDocument)) !== null && _ownerDocumentCounts$ !== void 0 ? _ownerDocumentCounts$ : 0;\n  ownerDocumentCounts.set(ownerDocument, count + 1);\n  registeredResizeHandlers.add(data);\n  updateListeners();\n  return function unregisterResizeHandle() {\n    var _ownerDocumentCounts$2;\n    panelConstraintFlags.delete(resizeHandleId);\n    registeredResizeHandlers.delete(data);\n    const count = (_ownerDocumentCounts$2 = ownerDocumentCounts.get(ownerDocument)) !== null && _ownerDocumentCounts$2 !== void 0 ? _ownerDocumentCounts$2 : 1;\n    ownerDocumentCounts.set(ownerDocument, count - 1);\n    updateListeners();\n    if (count === 1) {\n      ownerDocumentCounts.delete(ownerDocument);\n    }\n\n    // If the resize handle that is currently unmounting is intersecting with the pointer,\n    // update the global pointer to account for the change\n    if (intersectingHandles.includes(data)) {\n      const index = intersectingHandles.indexOf(data);\n      if (index >= 0) {\n        intersectingHandles.splice(index, 1);\n      }\n      updateCursor();\n\n      // Also instruct the handle to stop dragging; this prevents the parent group from being left in an inconsistent state\n      // See github.com/bvaughn/react-resizable-panels/issues/402\n      setResizeHandlerState(\"up\", true, null);\n    }\n  };\n}\nfunction handlePointerDown(event) {\n  const {\n    target\n  } = event;\n  const {\n    x,\n    y\n  } = getResizeEventCoordinates(event);\n  isPointerDown = true;\n  recalculateIntersectingHandles({\n    target,\n    x,\n    y\n  });\n  updateListeners();\n  if (intersectingHandles.length > 0) {\n    updateResizeHandlerStates(\"down\", event);\n    event.preventDefault();\n    if (!isWithinResizeHandle(target)) {\n      event.stopImmediatePropagation();\n    }\n  }\n}\nfunction handlePointerMove(event) {\n  const {\n    x,\n    y\n  } = getResizeEventCoordinates(event);\n\n  // Edge case (see #340)\n  // Detect when the pointer has been released outside an iframe on a different domain\n  if (isPointerDown && event.buttons === 0) {\n    isPointerDown = false;\n    updateResizeHandlerStates(\"up\", event);\n  }\n  if (!isPointerDown) {\n    const {\n      target\n    } = event;\n\n    // Recalculate intersecting handles whenever the pointer moves, except if it has already been pressed\n    // at that point, the handles may not move with the pointer (depending on constraints)\n    // but the same set of active handles should be locked until the pointer is released\n    recalculateIntersectingHandles({\n      target,\n      x,\n      y\n    });\n  }\n  updateResizeHandlerStates(\"move\", event);\n\n  // Update cursor based on return value(s) from active handles\n  updateCursor();\n  if (intersectingHandles.length > 0) {\n    event.preventDefault();\n  }\n}\nfunction handlePointerUp(event) {\n  const {\n    target\n  } = event;\n  const {\n    x,\n    y\n  } = getResizeEventCoordinates(event);\n  panelConstraintFlags.clear();\n  isPointerDown = false;\n  if (intersectingHandles.length > 0) {\n    event.preventDefault();\n    if (!isWithinResizeHandle(target)) {\n      event.stopImmediatePropagation();\n    }\n  }\n  updateResizeHandlerStates(\"up\", event);\n  recalculateIntersectingHandles({\n    target,\n    x,\n    y\n  });\n  updateCursor();\n  updateListeners();\n}\nfunction isWithinResizeHandle(element) {\n  let currentElement = element;\n  while (currentElement) {\n    if (currentElement.hasAttribute(DATA_ATTRIBUTES.resizeHandle)) {\n      return true;\n    }\n    currentElement = currentElement.parentElement;\n  }\n  return false;\n}\nfunction recalculateIntersectingHandles({\n  target,\n  x,\n  y\n}) {\n  intersectingHandles.splice(0);\n  let targetElement = null;\n  if (target instanceof HTMLElement || target instanceof SVGElement) {\n    targetElement = target;\n  }\n  registeredResizeHandlers.forEach(data => {\n    const {\n      element: dragHandleElement,\n      hitAreaMargins\n    } = data;\n    const dragHandleRect = dragHandleElement.getBoundingClientRect();\n    const {\n      bottom,\n      left,\n      right,\n      top\n    } = dragHandleRect;\n    const margin = isCoarsePointer ? hitAreaMargins.coarse : hitAreaMargins.fine;\n    const eventIntersects = x >= left - margin && x <= right + margin && y >= top - margin && y <= bottom + margin;\n    if (eventIntersects) {\n      // TRICKY\n      // We listen for pointers events at the root in order to support hit area margins\n      // (determining when the pointer is close enough to an element to be considered a \"hit\")\n      // Clicking on an element \"above\" a handle (e.g. a modal) should prevent a hit though\n      // so at this point we need to compare stacking order of a potentially intersecting drag handle,\n      // and the element that was actually clicked/touched\n      if (targetElement !== null && document.contains(targetElement) && dragHandleElement !== targetElement && !dragHandleElement.contains(targetElement) && !targetElement.contains(dragHandleElement) &&\n      // Calculating stacking order has a cost, so we should avoid it if possible\n      // That is why we only check potentially intersecting handles,\n      // and why we skip if the event target is within the handle's DOM\n      compare(targetElement, dragHandleElement) > 0) {\n        // If the target is above the drag handle, then we also need to confirm they overlap\n        // If they are beside each other (e.g. a panel and its drag handle) then the handle is still interactive\n        //\n        // It's not enough to compare only the target\n        // The target might be a small element inside of a larger container\n        // (For example, a SPAN or a DIV inside of a larger modal dialog)\n        let currentElement = targetElement;\n        let didIntersect = false;\n        while (currentElement) {\n          if (currentElement.contains(dragHandleElement)) {\n            break;\n          } else if (intersects(currentElement.getBoundingClientRect(), dragHandleRect, true)) {\n            didIntersect = true;\n            break;\n          }\n          currentElement = currentElement.parentElement;\n        }\n        if (didIntersect) {\n          return;\n        }\n      }\n      intersectingHandles.push(data);\n    }\n  });\n}\nfunction reportConstraintsViolation(resizeHandleId, flag) {\n  panelConstraintFlags.set(resizeHandleId, flag);\n}\nfunction updateCursor() {\n  let intersectsHorizontal = false;\n  let intersectsVertical = false;\n  intersectingHandles.forEach(data => {\n    const {\n      direction\n    } = data;\n    if (direction === \"horizontal\") {\n      intersectsHorizontal = true;\n    } else {\n      intersectsVertical = true;\n    }\n  });\n  let constraintFlags = 0;\n  panelConstraintFlags.forEach(flag => {\n    constraintFlags |= flag;\n  });\n  if (intersectsHorizontal && intersectsVertical) {\n    setGlobalCursorStyle(\"intersection\", constraintFlags);\n  } else if (intersectsHorizontal) {\n    setGlobalCursorStyle(\"horizontal\", constraintFlags);\n  } else if (intersectsVertical) {\n    setGlobalCursorStyle(\"vertical\", constraintFlags);\n  } else {\n    resetGlobalCursorStyle();\n  }\n}\nlet listenersAbortController;\nfunction updateListeners() {\n  var _listenersAbortContro;\n  (_listenersAbortContro = listenersAbortController) === null || _listenersAbortContro === void 0 ? void 0 : _listenersAbortContro.abort();\n  listenersAbortController = new AbortController();\n  const options = {\n    capture: true,\n    signal: listenersAbortController.signal\n  };\n  if (!registeredResizeHandlers.size) {\n    return;\n  }\n  if (isPointerDown) {\n    if (intersectingHandles.length > 0) {\n      ownerDocumentCounts.forEach((count, ownerDocument) => {\n        const {\n          body\n        } = ownerDocument;\n        if (count > 0) {\n          body.addEventListener(\"contextmenu\", handlePointerUp, options);\n          body.addEventListener(\"pointerleave\", handlePointerMove, options);\n          body.addEventListener(\"pointermove\", handlePointerMove, options);\n        }\n      });\n    }\n    ownerDocumentCounts.forEach((_, ownerDocument) => {\n      const {\n        body\n      } = ownerDocument;\n      body.addEventListener(\"pointerup\", handlePointerUp, options);\n      body.addEventListener(\"pointercancel\", handlePointerUp, options);\n    });\n  } else {\n    ownerDocumentCounts.forEach((count, ownerDocument) => {\n      const {\n        body\n      } = ownerDocument;\n      if (count > 0) {\n        body.addEventListener(\"pointerdown\", handlePointerDown, options);\n        body.addEventListener(\"pointermove\", handlePointerMove, options);\n      }\n    });\n  }\n}\nfunction updateResizeHandlerStates(action, event) {\n  registeredResizeHandlers.forEach(data => {\n    const {\n      setResizeHandlerState\n    } = data;\n    const isActive = intersectingHandles.includes(data);\n    setResizeHandlerState(action, isActive, event);\n  });\n}\n\nfunction useForceUpdate() {\n  const [_, setCount] = useState(0);\n  return useCallback(() => setCount(prevCount => prevCount + 1), []);\n}\n\nfunction assert(expectedCondition, message) {\n  if (!expectedCondition) {\n    console.error(message);\n    throw Error(message);\n  }\n}\n\nfunction fuzzyCompareNumbers(actual, expected, fractionDigits = PRECISION) {\n  if (actual.toFixed(fractionDigits) === expected.toFixed(fractionDigits)) {\n    return 0;\n  } else {\n    return actual > expected ? 1 : -1;\n  }\n}\nfunction fuzzyNumbersEqual$1(actual, expected, fractionDigits = PRECISION) {\n  return fuzzyCompareNumbers(actual, expected, fractionDigits) === 0;\n}\n\nfunction fuzzyNumbersEqual(actual, expected, fractionDigits) {\n  return fuzzyCompareNumbers(actual, expected, fractionDigits) === 0;\n}\n\nfunction fuzzyLayoutsEqual(actual, expected, fractionDigits) {\n  if (actual.length !== expected.length) {\n    return false;\n  }\n  for (let index = 0; index < actual.length; index++) {\n    const actualSize = actual[index];\n    const expectedSize = expected[index];\n    if (!fuzzyNumbersEqual(actualSize, expectedSize, fractionDigits)) {\n      return false;\n    }\n  }\n  return true;\n}\n\n// Panel size must be in percentages; pixel values should be pre-converted\nfunction resizePanel({\n  panelConstraints: panelConstraintsArray,\n  panelIndex,\n  size\n}) {\n  const panelConstraints = panelConstraintsArray[panelIndex];\n  assert(panelConstraints != null, `Panel constraints not found for index ${panelIndex}`);\n  let {\n    collapsedSize = 0,\n    collapsible,\n    maxSize = 100,\n    minSize = 0\n  } = panelConstraints;\n  if (fuzzyCompareNumbers(size, minSize) < 0) {\n    if (collapsible) {\n      // Collapsible panels should snap closed or open only once they cross the halfway point between collapsed and min size.\n      const halfwayPoint = (collapsedSize + minSize) / 2;\n      if (fuzzyCompareNumbers(size, halfwayPoint) < 0) {\n        size = collapsedSize;\n      } else {\n        size = minSize;\n      }\n    } else {\n      size = minSize;\n    }\n  }\n  size = Math.min(maxSize, size);\n  size = parseFloat(size.toFixed(PRECISION));\n  return size;\n}\n\n// All units must be in percentages; pixel values should be pre-converted\nfunction adjustLayoutByDelta({\n  delta,\n  initialLayout,\n  panelConstraints: panelConstraintsArray,\n  pivotIndices,\n  prevLayout,\n  trigger\n}) {\n  if (fuzzyNumbersEqual(delta, 0)) {\n    return initialLayout;\n  }\n  const nextLayout = [...initialLayout];\n  const [firstPivotIndex, secondPivotIndex] = pivotIndices;\n  assert(firstPivotIndex != null, \"Invalid first pivot index\");\n  assert(secondPivotIndex != null, \"Invalid second pivot index\");\n  let deltaApplied = 0;\n\n  // const DEBUG = [];\n  // DEBUG.push(`adjustLayoutByDelta()`);\n  // DEBUG.push(`  initialLayout: ${initialLayout.join(\", \")}`);\n  // DEBUG.push(`  prevLayout: ${prevLayout.join(\", \")}`);\n  // DEBUG.push(`  delta: ${delta}`);\n  // DEBUG.push(`  pivotIndices: ${pivotIndices.join(\", \")}`);\n  // DEBUG.push(`  trigger: ${trigger}`);\n  // DEBUG.push(\"\");\n\n  // A resizing panel affects the panels before or after it.\n  //\n  // A negative delta means the panel(s) immediately after the resize handle should grow/expand by decreasing its offset.\n  // Other panels may also need to shrink/contract (and shift) to make room, depending on the min weights.\n  //\n  // A positive delta means the panel(s) immediately before the resize handle should \"expand\".\n  // This is accomplished by shrinking/contracting (and shifting) one or more of the panels after the resize handle.\n\n  {\n    // If this is a resize triggered by a keyboard event, our logic for expanding/collapsing is different.\n    // We no longer check the halfway threshold because this may prevent the panel from expanding at all.\n    if (trigger === \"keyboard\") {\n      {\n        // Check if we should expand a collapsed panel\n        const index = delta < 0 ? secondPivotIndex : firstPivotIndex;\n        const panelConstraints = panelConstraintsArray[index];\n        assert(panelConstraints, `Panel constraints not found for index ${index}`);\n        const {\n          collapsedSize = 0,\n          collapsible,\n          minSize = 0\n        } = panelConstraints;\n\n        // DEBUG.push(`edge case check 1: ${index}`);\n        // DEBUG.push(`  -> collapsible? ${collapsible}`);\n        if (collapsible) {\n          const prevSize = initialLayout[index];\n          assert(prevSize != null, `Previous layout not found for panel index ${index}`);\n          if (fuzzyNumbersEqual(prevSize, collapsedSize)) {\n            const localDelta = minSize - prevSize;\n            // DEBUG.push(`  -> expand delta: ${localDelta}`);\n\n            if (fuzzyCompareNumbers(localDelta, Math.abs(delta)) > 0) {\n              delta = delta < 0 ? 0 - localDelta : localDelta;\n              // DEBUG.push(`  -> delta: ${delta}`);\n            }\n          }\n        }\n      }\n\n      {\n        // Check if we should collapse a panel at its minimum size\n        const index = delta < 0 ? firstPivotIndex : secondPivotIndex;\n        const panelConstraints = panelConstraintsArray[index];\n        assert(panelConstraints, `No panel constraints found for index ${index}`);\n        const {\n          collapsedSize = 0,\n          collapsible,\n          minSize = 0\n        } = panelConstraints;\n\n        // DEBUG.push(`edge case check 2: ${index}`);\n        // DEBUG.push(`  -> collapsible? ${collapsible}`);\n        if (collapsible) {\n          const prevSize = initialLayout[index];\n          assert(prevSize != null, `Previous layout not found for panel index ${index}`);\n          if (fuzzyNumbersEqual(prevSize, minSize)) {\n            const localDelta = prevSize - collapsedSize;\n            // DEBUG.push(`  -> expand delta: ${localDelta}`);\n\n            if (fuzzyCompareNumbers(localDelta, Math.abs(delta)) > 0) {\n              delta = delta < 0 ? 0 - localDelta : localDelta;\n              // DEBUG.push(`  -> delta: ${delta}`);\n            }\n          }\n        }\n      }\n    }\n    // DEBUG.push(\"\");\n  }\n\n  {\n    // Pre-calculate max available delta in the opposite direction of our pivot.\n    // This will be the maximum amount we're allowed to expand/contract the panels in the primary direction.\n    // If this amount is less than the requested delta, adjust the requested delta.\n    // If this amount is greater than the requested delta, that's useful information too–\n    // as an expanding panel might change from collapsed to min size.\n\n    const increment = delta < 0 ? 1 : -1;\n    let index = delta < 0 ? secondPivotIndex : firstPivotIndex;\n    let maxAvailableDelta = 0;\n\n    // DEBUG.push(\"pre calc...\");\n    while (true) {\n      const prevSize = initialLayout[index];\n      assert(prevSize != null, `Previous layout not found for panel index ${index}`);\n      const maxSafeSize = resizePanel({\n        panelConstraints: panelConstraintsArray,\n        panelIndex: index,\n        size: 100\n      });\n      const delta = maxSafeSize - prevSize;\n      // DEBUG.push(`  ${index}: ${prevSize} -> ${maxSafeSize}`);\n\n      maxAvailableDelta += delta;\n      index += increment;\n      if (index < 0 || index >= panelConstraintsArray.length) {\n        break;\n      }\n    }\n\n    // DEBUG.push(`  -> max available delta: ${maxAvailableDelta}`);\n    const minAbsDelta = Math.min(Math.abs(delta), Math.abs(maxAvailableDelta));\n    delta = delta < 0 ? 0 - minAbsDelta : minAbsDelta;\n    // DEBUG.push(`  -> adjusted delta: ${delta}`);\n    // DEBUG.push(\"\");\n  }\n\n  {\n    // Delta added to a panel needs to be subtracted from other panels (within the constraints that those panels allow).\n\n    const pivotIndex = delta < 0 ? firstPivotIndex : secondPivotIndex;\n    let index = pivotIndex;\n    while (index >= 0 && index < panelConstraintsArray.length) {\n      const deltaRemaining = Math.abs(delta) - Math.abs(deltaApplied);\n      const prevSize = initialLayout[index];\n      assert(prevSize != null, `Previous layout not found for panel index ${index}`);\n      const unsafeSize = prevSize - deltaRemaining;\n      const safeSize = resizePanel({\n        panelConstraints: panelConstraintsArray,\n        panelIndex: index,\n        size: unsafeSize\n      });\n      if (!fuzzyNumbersEqual(prevSize, safeSize)) {\n        deltaApplied += prevSize - safeSize;\n        nextLayout[index] = safeSize;\n        if (deltaApplied.toPrecision(3).localeCompare(Math.abs(delta).toPrecision(3), undefined, {\n          numeric: true\n        }) >= 0) {\n          break;\n        }\n      }\n      if (delta < 0) {\n        index--;\n      } else {\n        index++;\n      }\n    }\n  }\n  // DEBUG.push(`after 1: ${nextLayout.join(\", \")}`);\n  // DEBUG.push(`  deltaApplied: ${deltaApplied}`);\n  // DEBUG.push(\"\");\n\n  // If we were unable to resize any of the panels panels, return the previous state.\n  // This will essentially bailout and ignore e.g. drags past a panel's boundaries\n  if (fuzzyLayoutsEqual(prevLayout, nextLayout)) {\n    // DEBUG.push(`bailout to previous layout: ${prevLayout.join(\", \")}`);\n    // console.log(DEBUG.join(\"\\n\"));\n\n    return prevLayout;\n  }\n  {\n    // Now distribute the applied delta to the panels in the other direction\n    const pivotIndex = delta < 0 ? secondPivotIndex : firstPivotIndex;\n    const prevSize = initialLayout[pivotIndex];\n    assert(prevSize != null, `Previous layout not found for panel index ${pivotIndex}`);\n    const unsafeSize = prevSize + deltaApplied;\n    const safeSize = resizePanel({\n      panelConstraints: panelConstraintsArray,\n      panelIndex: pivotIndex,\n      size: unsafeSize\n    });\n\n    // Adjust the pivot panel before, but only by the amount that surrounding panels were able to shrink/contract.\n    nextLayout[pivotIndex] = safeSize;\n\n    // Edge case where expanding or contracting one panel caused another one to change collapsed state\n    if (!fuzzyNumbersEqual(safeSize, unsafeSize)) {\n      let deltaRemaining = unsafeSize - safeSize;\n      const pivotIndex = delta < 0 ? secondPivotIndex : firstPivotIndex;\n      let index = pivotIndex;\n      while (index >= 0 && index < panelConstraintsArray.length) {\n        const prevSize = nextLayout[index];\n        assert(prevSize != null, `Previous layout not found for panel index ${index}`);\n        const unsafeSize = prevSize + deltaRemaining;\n        const safeSize = resizePanel({\n          panelConstraints: panelConstraintsArray,\n          panelIndex: index,\n          size: unsafeSize\n        });\n        if (!fuzzyNumbersEqual(prevSize, safeSize)) {\n          deltaRemaining -= safeSize - prevSize;\n          nextLayout[index] = safeSize;\n        }\n        if (fuzzyNumbersEqual(deltaRemaining, 0)) {\n          break;\n        }\n        if (delta > 0) {\n          index--;\n        } else {\n          index++;\n        }\n      }\n    }\n  }\n  // DEBUG.push(`after 2: ${nextLayout.join(\", \")}`);\n  // DEBUG.push(`  deltaApplied: ${deltaApplied}`);\n  // DEBUG.push(\"\");\n\n  const totalSize = nextLayout.reduce((total, size) => size + total, 0);\n  // DEBUG.push(`total size: ${totalSize}`);\n\n  // If our new layout doesn't add up to 100%, that means the requested delta can't be applied\n  // In that case, fall back to our most recent valid layout\n  if (!fuzzyNumbersEqual(totalSize, 100)) {\n    // DEBUG.push(`bailout to previous layout: ${prevLayout.join(\", \")}`);\n    // console.log(DEBUG.join(\"\\n\"));\n\n    return prevLayout;\n  }\n\n  // console.log(DEBUG.join(\"\\n\"));\n  return nextLayout;\n}\n\nfunction calculateAriaValues({\n  layout,\n  panelsArray,\n  pivotIndices\n}) {\n  let currentMinSize = 0;\n  let currentMaxSize = 100;\n  let totalMinSize = 0;\n  let totalMaxSize = 0;\n  const firstIndex = pivotIndices[0];\n  assert(firstIndex != null, \"No pivot index found\");\n\n  // A panel's effective min/max sizes also need to account for other panel's sizes.\n  panelsArray.forEach((panelData, index) => {\n    const {\n      constraints\n    } = panelData;\n    const {\n      maxSize = 100,\n      minSize = 0\n    } = constraints;\n    if (index === firstIndex) {\n      currentMinSize = minSize;\n      currentMaxSize = maxSize;\n    } else {\n      totalMinSize += minSize;\n      totalMaxSize += maxSize;\n    }\n  });\n  const valueMax = Math.min(currentMaxSize, 100 - totalMinSize);\n  const valueMin = Math.max(currentMinSize, 100 - totalMaxSize);\n  const valueNow = layout[firstIndex];\n  return {\n    valueMax,\n    valueMin,\n    valueNow\n  };\n}\n\nfunction getResizeHandleElementsForGroup(groupId, scope = document) {\n  return Array.from(scope.querySelectorAll(`[${DATA_ATTRIBUTES.resizeHandleId}][data-panel-group-id=\"${groupId}\"]`));\n}\n\nfunction getResizeHandleElementIndex(groupId, id, scope = document) {\n  const handles = getResizeHandleElementsForGroup(groupId, scope);\n  const index = handles.findIndex(handle => handle.getAttribute(DATA_ATTRIBUTES.resizeHandleId) === id);\n  return index !== null && index !== void 0 ? index : null;\n}\n\nfunction determinePivotIndices(groupId, dragHandleId, panelGroupElement) {\n  const index = getResizeHandleElementIndex(groupId, dragHandleId, panelGroupElement);\n  return index != null ? [index, index + 1] : [-1, -1];\n}\n\nfunction isHTMLElement(target) {\n  if (target instanceof HTMLElement) {\n    return true;\n  }\n\n  // Fallback to duck typing to handle edge case of portals within a popup window\n  return typeof target === \"object\" && target !== null && \"tagName\" in target && \"getAttribute\" in target;\n}\n\nfunction getPanelGroupElement(id, rootElement = document) {\n  // If the root element is the PanelGroup\n  if (isHTMLElement(rootElement) && rootElement.dataset.panelGroupId == id) {\n    return rootElement;\n  }\n\n  // Else query children\n  const element = rootElement.querySelector(`[data-panel-group][data-panel-group-id=\"${id}\"]`);\n  if (element) {\n    return element;\n  }\n  return null;\n}\n\nfunction getResizeHandleElement(id, scope = document) {\n  const element = scope.querySelector(`[${DATA_ATTRIBUTES.resizeHandleId}=\"${id}\"]`);\n  if (element) {\n    return element;\n  }\n  return null;\n}\n\nfunction getResizeHandlePanelIds(groupId, handleId, panelsArray, scope = document) {\n  var _panelsArray$index$id, _panelsArray$index, _panelsArray$id, _panelsArray;\n  const handle = getResizeHandleElement(handleId, scope);\n  const handles = getResizeHandleElementsForGroup(groupId, scope);\n  const index = handle ? handles.indexOf(handle) : -1;\n  const idBefore = (_panelsArray$index$id = (_panelsArray$index = panelsArray[index]) === null || _panelsArray$index === void 0 ? void 0 : _panelsArray$index.id) !== null && _panelsArray$index$id !== void 0 ? _panelsArray$index$id : null;\n  const idAfter = (_panelsArray$id = (_panelsArray = panelsArray[index + 1]) === null || _panelsArray === void 0 ? void 0 : _panelsArray.id) !== null && _panelsArray$id !== void 0 ? _panelsArray$id : null;\n  return [idBefore, idAfter];\n}\n\n// https://www.w3.org/WAI/ARIA/apg/patterns/windowsplitter/\n\nfunction useWindowSplitterPanelGroupBehavior({\n  committedValuesRef,\n  eagerValuesRef,\n  groupId,\n  layout,\n  panelDataArray,\n  panelGroupElement,\n  setLayout\n}) {\n  const devWarningsRef = useRef({\n    didWarnAboutMissingResizeHandle: false\n  });\n  useIsomorphicLayoutEffect(() => {\n    if (!panelGroupElement) {\n      return;\n    }\n    const resizeHandleElements = getResizeHandleElementsForGroup(groupId, panelGroupElement);\n    for (let index = 0; index < panelDataArray.length - 1; index++) {\n      const {\n        valueMax,\n        valueMin,\n        valueNow\n      } = calculateAriaValues({\n        layout,\n        panelsArray: panelDataArray,\n        pivotIndices: [index, index + 1]\n      });\n      const resizeHandleElement = resizeHandleElements[index];\n      if (resizeHandleElement == null) {\n        {\n          const {\n            didWarnAboutMissingResizeHandle\n          } = devWarningsRef.current;\n          if (!didWarnAboutMissingResizeHandle) {\n            devWarningsRef.current.didWarnAboutMissingResizeHandle = true;\n            console.warn(`WARNING: Missing resize handle for PanelGroup \"${groupId}\"`);\n          }\n        }\n      } else {\n        const panelData = panelDataArray[index];\n        assert(panelData, `No panel data found for index \"${index}\"`);\n        resizeHandleElement.setAttribute(\"aria-controls\", panelData.id);\n        resizeHandleElement.setAttribute(\"aria-valuemax\", \"\" + Math.round(valueMax));\n        resizeHandleElement.setAttribute(\"aria-valuemin\", \"\" + Math.round(valueMin));\n        resizeHandleElement.setAttribute(\"aria-valuenow\", valueNow != null ? \"\" + Math.round(valueNow) : \"\");\n      }\n    }\n    return () => {\n      resizeHandleElements.forEach((resizeHandleElement, index) => {\n        resizeHandleElement.removeAttribute(\"aria-controls\");\n        resizeHandleElement.removeAttribute(\"aria-valuemax\");\n        resizeHandleElement.removeAttribute(\"aria-valuemin\");\n        resizeHandleElement.removeAttribute(\"aria-valuenow\");\n      });\n    };\n  }, [groupId, layout, panelDataArray, panelGroupElement]);\n  useEffect(() => {\n    if (!panelGroupElement) {\n      return;\n    }\n    const eagerValues = eagerValuesRef.current;\n    assert(eagerValues, `Eager values not found`);\n    const {\n      panelDataArray\n    } = eagerValues;\n    const groupElement = getPanelGroupElement(groupId, panelGroupElement);\n    assert(groupElement != null, `No group found for id \"${groupId}\"`);\n    const handles = getResizeHandleElementsForGroup(groupId, panelGroupElement);\n    assert(handles, `No resize handles found for group id \"${groupId}\"`);\n    const cleanupFunctions = handles.map(handle => {\n      const handleId = handle.getAttribute(DATA_ATTRIBUTES.resizeHandleId);\n      assert(handleId, `Resize handle element has no handle id attribute`);\n      const [idBefore, idAfter] = getResizeHandlePanelIds(groupId, handleId, panelDataArray, panelGroupElement);\n      if (idBefore == null || idAfter == null) {\n        return () => {};\n      }\n      const onKeyDown = event => {\n        if (event.defaultPrevented) {\n          return;\n        }\n        switch (event.key) {\n          case \"Enter\":\n            {\n              event.preventDefault();\n              const index = panelDataArray.findIndex(panelData => panelData.id === idBefore);\n              if (index >= 0) {\n                const panelData = panelDataArray[index];\n                assert(panelData, `No panel data found for index ${index}`);\n                const size = layout[index];\n                const {\n                  collapsedSize = 0,\n                  collapsible,\n                  minSize = 0\n                } = panelData.constraints;\n                if (size != null && collapsible) {\n                  const nextLayout = adjustLayoutByDelta({\n                    delta: fuzzyNumbersEqual(size, collapsedSize) ? minSize - collapsedSize : collapsedSize - size,\n                    initialLayout: layout,\n                    panelConstraints: panelDataArray.map(panelData => panelData.constraints),\n                    pivotIndices: determinePivotIndices(groupId, handleId, panelGroupElement),\n                    prevLayout: layout,\n                    trigger: \"keyboard\"\n                  });\n                  if (layout !== nextLayout) {\n                    setLayout(nextLayout);\n                  }\n                }\n              }\n              break;\n            }\n        }\n      };\n      handle.addEventListener(\"keydown\", onKeyDown);\n      return () => {\n        handle.removeEventListener(\"keydown\", onKeyDown);\n      };\n    });\n    return () => {\n      cleanupFunctions.forEach(cleanupFunction => cleanupFunction());\n    };\n  }, [panelGroupElement, committedValuesRef, eagerValuesRef, groupId, layout, panelDataArray, setLayout]);\n}\n\nfunction areEqual(arrayA, arrayB) {\n  if (arrayA.length !== arrayB.length) {\n    return false;\n  }\n  for (let index = 0; index < arrayA.length; index++) {\n    if (arrayA[index] !== arrayB[index]) {\n      return false;\n    }\n  }\n  return true;\n}\n\nfunction getResizeEventCursorPosition(direction, event) {\n  const isHorizontal = direction === \"horizontal\";\n  const {\n    x,\n    y\n  } = getResizeEventCoordinates(event);\n  return isHorizontal ? x : y;\n}\n\nfunction calculateDragOffsetPercentage(event, dragHandleId, direction, initialDragState, panelGroupElement) {\n  const isHorizontal = direction === \"horizontal\";\n  const handleElement = getResizeHandleElement(dragHandleId, panelGroupElement);\n  assert(handleElement, `No resize handle element found for id \"${dragHandleId}\"`);\n  const groupId = handleElement.getAttribute(DATA_ATTRIBUTES.groupId);\n  assert(groupId, `Resize handle element has no group id attribute`);\n  let {\n    initialCursorPosition\n  } = initialDragState;\n  const cursorPosition = getResizeEventCursorPosition(direction, event);\n  const groupElement = getPanelGroupElement(groupId, panelGroupElement);\n  assert(groupElement, `No group element found for id \"${groupId}\"`);\n  const groupRect = groupElement.getBoundingClientRect();\n  const groupSizeInPixels = isHorizontal ? groupRect.width : groupRect.height;\n  const offsetPixels = cursorPosition - initialCursorPosition;\n  const offsetPercentage = offsetPixels / groupSizeInPixels * 100;\n  return offsetPercentage;\n}\n\n// https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/movementX\nfunction calculateDeltaPercentage(event, dragHandleId, direction, initialDragState, keyboardResizeBy, panelGroupElement) {\n  if (isKeyDown(event)) {\n    const isHorizontal = direction === \"horizontal\";\n    let delta = 0;\n    if (event.shiftKey) {\n      delta = 100;\n    } else if (keyboardResizeBy != null) {\n      delta = keyboardResizeBy;\n    } else {\n      delta = 10;\n    }\n    let movement = 0;\n    switch (event.key) {\n      case \"ArrowDown\":\n        movement = isHorizontal ? 0 : delta;\n        break;\n      case \"ArrowLeft\":\n        movement = isHorizontal ? -delta : 0;\n        break;\n      case \"ArrowRight\":\n        movement = isHorizontal ? delta : 0;\n        break;\n      case \"ArrowUp\":\n        movement = isHorizontal ? 0 : -delta;\n        break;\n      case \"End\":\n        movement = 100;\n        break;\n      case \"Home\":\n        movement = -100;\n        break;\n    }\n    return movement;\n  } else {\n    if (initialDragState == null) {\n      return 0;\n    }\n    return calculateDragOffsetPercentage(event, dragHandleId, direction, initialDragState, panelGroupElement);\n  }\n}\n\nfunction calculateUnsafeDefaultLayout({\n  panelDataArray\n}) {\n  const layout = Array(panelDataArray.length);\n  const panelConstraintsArray = panelDataArray.map(panelData => panelData.constraints);\n  let numPanelsWithSizes = 0;\n  let remainingSize = 100;\n\n  // Distribute default sizes first\n  for (let index = 0; index < panelDataArray.length; index++) {\n    const panelConstraints = panelConstraintsArray[index];\n    assert(panelConstraints, `Panel constraints not found for index ${index}`);\n    const {\n      defaultSize\n    } = panelConstraints;\n    if (defaultSize != null) {\n      numPanelsWithSizes++;\n      layout[index] = defaultSize;\n      remainingSize -= defaultSize;\n    }\n  }\n\n  // Remaining size should be distributed evenly between panels without default sizes\n  for (let index = 0; index < panelDataArray.length; index++) {\n    const panelConstraints = panelConstraintsArray[index];\n    assert(panelConstraints, `Panel constraints not found for index ${index}`);\n    const {\n      defaultSize\n    } = panelConstraints;\n    if (defaultSize != null) {\n      continue;\n    }\n    const numRemainingPanels = panelDataArray.length - numPanelsWithSizes;\n    const size = remainingSize / numRemainingPanels;\n    numPanelsWithSizes++;\n    layout[index] = size;\n    remainingSize -= size;\n  }\n  return layout;\n}\n\n// Layout should be pre-converted into percentages\nfunction callPanelCallbacks(panelsArray, layout, panelIdToLastNotifiedSizeMap) {\n  layout.forEach((size, index) => {\n    const panelData = panelsArray[index];\n    assert(panelData, `Panel data not found for index ${index}`);\n    const {\n      callbacks,\n      constraints,\n      id: panelId\n    } = panelData;\n    const {\n      collapsedSize = 0,\n      collapsible\n    } = constraints;\n    const lastNotifiedSize = panelIdToLastNotifiedSizeMap[panelId];\n    if (lastNotifiedSize == null || size !== lastNotifiedSize) {\n      panelIdToLastNotifiedSizeMap[panelId] = size;\n      const {\n        onCollapse,\n        onExpand,\n        onResize\n      } = callbacks;\n      if (onResize) {\n        onResize(size, lastNotifiedSize);\n      }\n      if (collapsible && (onCollapse || onExpand)) {\n        if (onExpand && (lastNotifiedSize == null || fuzzyNumbersEqual$1(lastNotifiedSize, collapsedSize)) && !fuzzyNumbersEqual$1(size, collapsedSize)) {\n          onExpand();\n        }\n        if (onCollapse && (lastNotifiedSize == null || !fuzzyNumbersEqual$1(lastNotifiedSize, collapsedSize)) && fuzzyNumbersEqual$1(size, collapsedSize)) {\n          onCollapse();\n        }\n      }\n    }\n  });\n}\n\nfunction compareLayouts(a, b) {\n  if (a.length !== b.length) {\n    return false;\n  } else {\n    for (let index = 0; index < a.length; index++) {\n      if (a[index] != b[index]) {\n        return false;\n      }\n    }\n  }\n  return true;\n}\n\n// This method returns a number between 1 and 100 representing\n\n// the % of the group's overall space this panel should occupy.\nfunction computePanelFlexBoxStyle({\n  defaultSize,\n  dragState,\n  layout,\n  panelData,\n  panelIndex,\n  precision = 3\n}) {\n  const size = layout[panelIndex];\n  let flexGrow;\n  if (size == null) {\n    // Initial render (before panels have registered themselves)\n    // In order to support server rendering, fall back to default size if provided\n    flexGrow = defaultSize != undefined ? defaultSize.toPrecision(precision) : \"1\";\n  } else if (panelData.length === 1) {\n    // Special case: Single panel group should always fill full width/height\n    flexGrow = \"1\";\n  } else {\n    flexGrow = size.toPrecision(precision);\n  }\n  return {\n    flexBasis: 0,\n    flexGrow,\n    flexShrink: 1,\n    // Without this, Panel sizes may be unintentionally overridden by their content\n    overflow: \"hidden\",\n    // Disable pointer events inside of a panel during resize\n    // This avoid edge cases like nested iframes\n    pointerEvents: dragState !== null ? \"none\" : undefined\n  };\n}\n\nfunction debounce(callback, durationMs = 10) {\n  let timeoutId = null;\n  let callable = (...args) => {\n    if (timeoutId !== null) {\n      clearTimeout(timeoutId);\n    }\n    timeoutId = setTimeout(() => {\n      callback(...args);\n    }, durationMs);\n  };\n  return callable;\n}\n\n// PanelGroup might be rendering in a server-side environment where localStorage is not available\n// or on a browser with cookies/storage disabled.\n// In either case, this function avoids accessing localStorage until needed,\n// and avoids throwing user-visible errors.\nfunction initializeDefaultStorage(storageObject) {\n  try {\n    if (typeof localStorage !== \"undefined\") {\n      // Bypass this check for future calls\n      storageObject.getItem = name => {\n        return localStorage.getItem(name);\n      };\n      storageObject.setItem = (name, value) => {\n        localStorage.setItem(name, value);\n      };\n    } else {\n      throw new Error(\"localStorage not supported in this environment\");\n    }\n  } catch (error) {\n    console.error(error);\n    storageObject.getItem = () => null;\n    storageObject.setItem = () => {};\n  }\n}\n\nfunction getPanelGroupKey(autoSaveId) {\n  return `react-resizable-panels:${autoSaveId}`;\n}\n\n// Note that Panel ids might be user-provided (stable) or useId generated (non-deterministic)\n// so they should not be used as part of the serialization key.\n// Using the min/max size attributes should work well enough as a backup.\n// Pre-sorting by minSize allows remembering layouts even if panels are re-ordered/dragged.\nfunction getPanelKey(panels) {\n  return panels.map(panel => {\n    const {\n      constraints,\n      id,\n      idIsFromProps,\n      order\n    } = panel;\n    if (idIsFromProps) {\n      return id;\n    } else {\n      return order ? `${order}:${JSON.stringify(constraints)}` : JSON.stringify(constraints);\n    }\n  }).sort((a, b) => a.localeCompare(b)).join(\",\");\n}\nfunction loadSerializedPanelGroupState(autoSaveId, storage) {\n  try {\n    const panelGroupKey = getPanelGroupKey(autoSaveId);\n    const serialized = storage.getItem(panelGroupKey);\n    if (serialized) {\n      const parsed = JSON.parse(serialized);\n      if (typeof parsed === \"object\" && parsed != null) {\n        return parsed;\n      }\n    }\n  } catch (error) {}\n  return null;\n}\nfunction loadPanelGroupState(autoSaveId, panels, storage) {\n  var _loadSerializedPanelG, _state$panelKey;\n  const state = (_loadSerializedPanelG = loadSerializedPanelGroupState(autoSaveId, storage)) !== null && _loadSerializedPanelG !== void 0 ? _loadSerializedPanelG : {};\n  const panelKey = getPanelKey(panels);\n  return (_state$panelKey = state[panelKey]) !== null && _state$panelKey !== void 0 ? _state$panelKey : null;\n}\nfunction savePanelGroupState(autoSaveId, panels, panelSizesBeforeCollapse, sizes, storage) {\n  var _loadSerializedPanelG2;\n  const panelGroupKey = getPanelGroupKey(autoSaveId);\n  const panelKey = getPanelKey(panels);\n  const state = (_loadSerializedPanelG2 = loadSerializedPanelGroupState(autoSaveId, storage)) !== null && _loadSerializedPanelG2 !== void 0 ? _loadSerializedPanelG2 : {};\n  state[panelKey] = {\n    expandToSizes: Object.fromEntries(panelSizesBeforeCollapse.entries()),\n    layout: sizes\n  };\n  try {\n    storage.setItem(panelGroupKey, JSON.stringify(state));\n  } catch (error) {\n    console.error(error);\n  }\n}\n\nfunction validatePanelConstraints({\n  panelConstraints: panelConstraintsArray,\n  panelId,\n  panelIndex\n}) {\n  {\n    const warnings = [];\n    const panelConstraints = panelConstraintsArray[panelIndex];\n    assert(panelConstraints, `No panel constraints found for index ${panelIndex}`);\n    const {\n      collapsedSize = 0,\n      collapsible = false,\n      defaultSize,\n      maxSize = 100,\n      minSize = 0\n    } = panelConstraints;\n    if (minSize > maxSize) {\n      warnings.push(`min size (${minSize}%) should not be greater than max size (${maxSize}%)`);\n    }\n    if (defaultSize != null) {\n      if (defaultSize < 0) {\n        warnings.push(\"default size should not be less than 0\");\n      } else if (defaultSize < minSize && (!collapsible || defaultSize !== collapsedSize)) {\n        warnings.push(\"default size should not be less than min size\");\n      }\n      if (defaultSize > 100) {\n        warnings.push(\"default size should not be greater than 100\");\n      } else if (defaultSize > maxSize) {\n        warnings.push(\"default size should not be greater than max size\");\n      }\n    }\n    if (collapsedSize > minSize) {\n      warnings.push(\"collapsed size should not be greater than min size\");\n    }\n    if (warnings.length > 0) {\n      const name = panelId != null ? `Panel \"${panelId}\"` : \"Panel\";\n      console.warn(`${name} has an invalid configuration:\\n\\n${warnings.join(\"\\n\")}`);\n      return false;\n    }\n  }\n  return true;\n}\n\n// All units must be in percentages; pixel values should be pre-converted\nfunction validatePanelGroupLayout({\n  layout: prevLayout,\n  panelConstraints\n}) {\n  const nextLayout = [...prevLayout];\n  const nextLayoutTotalSize = nextLayout.reduce((accumulated, current) => accumulated + current, 0);\n\n  // Validate layout expectations\n  if (nextLayout.length !== panelConstraints.length) {\n    throw Error(`Invalid ${panelConstraints.length} panel layout: ${nextLayout.map(size => `${size}%`).join(\", \")}`);\n  } else if (!fuzzyNumbersEqual(nextLayoutTotalSize, 100) && nextLayout.length > 0) {\n    // This is not ideal so we should warn about it, but it may be recoverable in some cases\n    // (especially if the amount is small)\n    {\n      console.warn(`WARNING: Invalid layout total size: ${nextLayout.map(size => `${size}%`).join(\", \")}. Layout normalization will be applied.`);\n    }\n    for (let index = 0; index < panelConstraints.length; index++) {\n      const unsafeSize = nextLayout[index];\n      assert(unsafeSize != null, `No layout data found for index ${index}`);\n      const safeSize = 100 / nextLayoutTotalSize * unsafeSize;\n      nextLayout[index] = safeSize;\n    }\n  }\n  let remainingSize = 0;\n\n  // First pass: Validate the proposed layout given each panel's constraints\n  for (let index = 0; index < panelConstraints.length; index++) {\n    const unsafeSize = nextLayout[index];\n    assert(unsafeSize != null, `No layout data found for index ${index}`);\n    const safeSize = resizePanel({\n      panelConstraints,\n      panelIndex: index,\n      size: unsafeSize\n    });\n    if (unsafeSize != safeSize) {\n      remainingSize += unsafeSize - safeSize;\n      nextLayout[index] = safeSize;\n    }\n  }\n\n  // If there is additional, left over space, assign it to any panel(s) that permits it\n  // (It's not worth taking multiple additional passes to evenly distribute)\n  if (!fuzzyNumbersEqual(remainingSize, 0)) {\n    for (let index = 0; index < panelConstraints.length; index++) {\n      const prevSize = nextLayout[index];\n      assert(prevSize != null, `No layout data found for index ${index}`);\n      const unsafeSize = prevSize + remainingSize;\n      const safeSize = resizePanel({\n        panelConstraints,\n        panelIndex: index,\n        size: unsafeSize\n      });\n      if (prevSize !== safeSize) {\n        remainingSize -= safeSize - prevSize;\n        nextLayout[index] = safeSize;\n\n        // Once we've used up the remainder, bail\n        if (fuzzyNumbersEqual(remainingSize, 0)) {\n          break;\n        }\n      }\n    }\n  }\n  return nextLayout;\n}\n\nconst LOCAL_STORAGE_DEBOUNCE_INTERVAL = 100;\nconst defaultStorage = {\n  getItem: name => {\n    initializeDefaultStorage(defaultStorage);\n    return defaultStorage.getItem(name);\n  },\n  setItem: (name, value) => {\n    initializeDefaultStorage(defaultStorage);\n    defaultStorage.setItem(name, value);\n  }\n};\nconst debounceMap = {};\nfunction PanelGroupWithForwardedRef({\n  autoSaveId = null,\n  children,\n  className: classNameFromProps = \"\",\n  direction,\n  forwardedRef,\n  id: idFromProps = null,\n  onLayout = null,\n  keyboardResizeBy = null,\n  storage = defaultStorage,\n  style: styleFromProps,\n  tagName: Type = \"div\",\n  ...rest\n}) {\n  const groupId = useUniqueId(idFromProps);\n  const panelGroupElementRef = useRef(null);\n  const [dragState, setDragState] = useState(null);\n  const [layout, setLayout] = useState([]);\n  const forceUpdate = useForceUpdate();\n  const panelIdToLastNotifiedSizeMapRef = useRef({});\n  const panelSizeBeforeCollapseRef = useRef(new Map());\n  const prevDeltaRef = useRef(0);\n  const committedValuesRef = useRef({\n    autoSaveId,\n    direction,\n    dragState,\n    id: groupId,\n    keyboardResizeBy,\n    onLayout,\n    storage\n  });\n  const eagerValuesRef = useRef({\n    layout,\n    panelDataArray: [],\n    panelDataArrayChanged: false\n  });\n  const devWarningsRef = useRef({\n    didLogIdAndOrderWarning: false,\n    didLogPanelConstraintsWarning: false,\n    prevPanelIds: []\n  });\n  useImperativeHandle(forwardedRef, () => ({\n    getId: () => committedValuesRef.current.id,\n    getLayout: () => {\n      const {\n        layout\n      } = eagerValuesRef.current;\n      return layout;\n    },\n    setLayout: unsafeLayout => {\n      const {\n        onLayout\n      } = committedValuesRef.current;\n      const {\n        layout: prevLayout,\n        panelDataArray\n      } = eagerValuesRef.current;\n      const safeLayout = validatePanelGroupLayout({\n        layout: unsafeLayout,\n        panelConstraints: panelDataArray.map(panelData => panelData.constraints)\n      });\n      if (!areEqual(prevLayout, safeLayout)) {\n        setLayout(safeLayout);\n        eagerValuesRef.current.layout = safeLayout;\n        if (onLayout) {\n          onLayout(safeLayout);\n        }\n        callPanelCallbacks(panelDataArray, safeLayout, panelIdToLastNotifiedSizeMapRef.current);\n      }\n    }\n  }), []);\n  useIsomorphicLayoutEffect(() => {\n    committedValuesRef.current.autoSaveId = autoSaveId;\n    committedValuesRef.current.direction = direction;\n    committedValuesRef.current.dragState = dragState;\n    committedValuesRef.current.id = groupId;\n    committedValuesRef.current.onLayout = onLayout;\n    committedValuesRef.current.storage = storage;\n  });\n  useWindowSplitterPanelGroupBehavior({\n    committedValuesRef,\n    eagerValuesRef,\n    groupId,\n    layout,\n    panelDataArray: eagerValuesRef.current.panelDataArray,\n    setLayout,\n    panelGroupElement: panelGroupElementRef.current\n  });\n  useEffect(() => {\n    const {\n      panelDataArray\n    } = eagerValuesRef.current;\n\n    // If this panel has been configured to persist sizing information, save sizes to local storage.\n    if (autoSaveId) {\n      if (layout.length === 0 || layout.length !== panelDataArray.length) {\n        return;\n      }\n      let debouncedSave = debounceMap[autoSaveId];\n\n      // Limit the frequency of localStorage updates.\n      if (debouncedSave == null) {\n        debouncedSave = debounce(savePanelGroupState, LOCAL_STORAGE_DEBOUNCE_INTERVAL);\n        debounceMap[autoSaveId] = debouncedSave;\n      }\n\n      // Clone mutable data before passing to the debounced function,\n      // else we run the risk of saving an incorrect combination of mutable and immutable values to state.\n      const clonedPanelDataArray = [...panelDataArray];\n      const clonedPanelSizesBeforeCollapse = new Map(panelSizeBeforeCollapseRef.current);\n      debouncedSave(autoSaveId, clonedPanelDataArray, clonedPanelSizesBeforeCollapse, layout, storage);\n    }\n  }, [autoSaveId, layout, storage]);\n\n  // DEV warnings\n  useEffect(() => {\n    {\n      const {\n        panelDataArray\n      } = eagerValuesRef.current;\n      const {\n        didLogIdAndOrderWarning,\n        didLogPanelConstraintsWarning,\n        prevPanelIds\n      } = devWarningsRef.current;\n      if (!didLogIdAndOrderWarning) {\n        const panelIds = panelDataArray.map(({\n          id\n        }) => id);\n        devWarningsRef.current.prevPanelIds = panelIds;\n        const panelsHaveChanged = prevPanelIds.length > 0 && !areEqual(prevPanelIds, panelIds);\n        if (panelsHaveChanged) {\n          if (panelDataArray.find(({\n            idIsFromProps,\n            order\n          }) => !idIsFromProps || order == null)) {\n            devWarningsRef.current.didLogIdAndOrderWarning = true;\n            console.warn(`WARNING: Panel id and order props recommended when panels are dynamically rendered`);\n          }\n        }\n      }\n      if (!didLogPanelConstraintsWarning) {\n        const panelConstraints = panelDataArray.map(panelData => panelData.constraints);\n        for (let panelIndex = 0; panelIndex < panelConstraints.length; panelIndex++) {\n          const panelData = panelDataArray[panelIndex];\n          assert(panelData, `Panel data not found for index ${panelIndex}`);\n          const isValid = validatePanelConstraints({\n            panelConstraints,\n            panelId: panelData.id,\n            panelIndex\n          });\n          if (!isValid) {\n            devWarningsRef.current.didLogPanelConstraintsWarning = true;\n            break;\n          }\n        }\n      }\n    }\n  });\n\n  // External APIs are safe to memoize via committed values ref\n  const collapsePanel = useCallback(panelData => {\n    const {\n      onLayout\n    } = committedValuesRef.current;\n    const {\n      layout: prevLayout,\n      panelDataArray\n    } = eagerValuesRef.current;\n    if (panelData.constraints.collapsible) {\n      const panelConstraintsArray = panelDataArray.map(panelData => panelData.constraints);\n      const {\n        collapsedSize = 0,\n        panelSize,\n        pivotIndices\n      } = panelDataHelper(panelDataArray, panelData, prevLayout);\n      assert(panelSize != null, `Panel size not found for panel \"${panelData.id}\"`);\n      if (!fuzzyNumbersEqual$1(panelSize, collapsedSize)) {\n        // Store size before collapse;\n        // This is the size that gets restored if the expand() API is used.\n        panelSizeBeforeCollapseRef.current.set(panelData.id, panelSize);\n        const isLastPanel = findPanelDataIndex(panelDataArray, panelData) === panelDataArray.length - 1;\n        const delta = isLastPanel ? panelSize - collapsedSize : collapsedSize - panelSize;\n        const nextLayout = adjustLayoutByDelta({\n          delta,\n          initialLayout: prevLayout,\n          panelConstraints: panelConstraintsArray,\n          pivotIndices,\n          prevLayout,\n          trigger: \"imperative-api\"\n        });\n        if (!compareLayouts(prevLayout, nextLayout)) {\n          setLayout(nextLayout);\n          eagerValuesRef.current.layout = nextLayout;\n          if (onLayout) {\n            onLayout(nextLayout);\n          }\n          callPanelCallbacks(panelDataArray, nextLayout, panelIdToLastNotifiedSizeMapRef.current);\n        }\n      }\n    }\n  }, []);\n\n  // External APIs are safe to memoize via committed values ref\n  const expandPanel = useCallback((panelData, minSizeOverride) => {\n    const {\n      onLayout\n    } = committedValuesRef.current;\n    const {\n      layout: prevLayout,\n      panelDataArray\n    } = eagerValuesRef.current;\n    if (panelData.constraints.collapsible) {\n      const panelConstraintsArray = panelDataArray.map(panelData => panelData.constraints);\n      const {\n        collapsedSize = 0,\n        panelSize = 0,\n        minSize: minSizeFromProps = 0,\n        pivotIndices\n      } = panelDataHelper(panelDataArray, panelData, prevLayout);\n      const minSize = minSizeOverride !== null && minSizeOverride !== void 0 ? minSizeOverride : minSizeFromProps;\n      if (fuzzyNumbersEqual$1(panelSize, collapsedSize)) {\n        // Restore this panel to the size it was before it was collapsed, if possible.\n        const prevPanelSize = panelSizeBeforeCollapseRef.current.get(panelData.id);\n        const baseSize = prevPanelSize != null && prevPanelSize >= minSize ? prevPanelSize : minSize;\n        const isLastPanel = findPanelDataIndex(panelDataArray, panelData) === panelDataArray.length - 1;\n        const delta = isLastPanel ? panelSize - baseSize : baseSize - panelSize;\n        const nextLayout = adjustLayoutByDelta({\n          delta,\n          initialLayout: prevLayout,\n          panelConstraints: panelConstraintsArray,\n          pivotIndices,\n          prevLayout,\n          trigger: \"imperative-api\"\n        });\n        if (!compareLayouts(prevLayout, nextLayout)) {\n          setLayout(nextLayout);\n          eagerValuesRef.current.layout = nextLayout;\n          if (onLayout) {\n            onLayout(nextLayout);\n          }\n          callPanelCallbacks(panelDataArray, nextLayout, panelIdToLastNotifiedSizeMapRef.current);\n        }\n      }\n    }\n  }, []);\n\n  // External APIs are safe to memoize via committed values ref\n  const getPanelSize = useCallback(panelData => {\n    const {\n      layout,\n      panelDataArray\n    } = eagerValuesRef.current;\n    const {\n      panelSize\n    } = panelDataHelper(panelDataArray, panelData, layout);\n    assert(panelSize != null, `Panel size not found for panel \"${panelData.id}\"`);\n    return panelSize;\n  }, []);\n\n  // This API should never read from committedValuesRef\n  const getPanelStyle = useCallback((panelData, defaultSize) => {\n    const {\n      panelDataArray\n    } = eagerValuesRef.current;\n    const panelIndex = findPanelDataIndex(panelDataArray, panelData);\n    return computePanelFlexBoxStyle({\n      defaultSize,\n      dragState,\n      layout,\n      panelData: panelDataArray,\n      panelIndex\n    });\n  }, [dragState, layout]);\n\n  // External APIs are safe to memoize via committed values ref\n  const isPanelCollapsed = useCallback(panelData => {\n    const {\n      layout,\n      panelDataArray\n    } = eagerValuesRef.current;\n    const {\n      collapsedSize = 0,\n      collapsible,\n      panelSize\n    } = panelDataHelper(panelDataArray, panelData, layout);\n    assert(panelSize != null, `Panel size not found for panel \"${panelData.id}\"`);\n    return collapsible === true && fuzzyNumbersEqual$1(panelSize, collapsedSize);\n  }, []);\n\n  // External APIs are safe to memoize via committed values ref\n  const isPanelExpanded = useCallback(panelData => {\n    const {\n      layout,\n      panelDataArray\n    } = eagerValuesRef.current;\n    const {\n      collapsedSize = 0,\n      collapsible,\n      panelSize\n    } = panelDataHelper(panelDataArray, panelData, layout);\n    assert(panelSize != null, `Panel size not found for panel \"${panelData.id}\"`);\n    return !collapsible || fuzzyCompareNumbers(panelSize, collapsedSize) > 0;\n  }, []);\n  const registerPanel = useCallback(panelData => {\n    const {\n      panelDataArray\n    } = eagerValuesRef.current;\n    panelDataArray.push(panelData);\n    panelDataArray.sort((panelA, panelB) => {\n      const orderA = panelA.order;\n      const orderB = panelB.order;\n      if (orderA == null && orderB == null) {\n        return 0;\n      } else if (orderA == null) {\n        return -1;\n      } else if (orderB == null) {\n        return 1;\n      } else {\n        return orderA - orderB;\n      }\n    });\n    eagerValuesRef.current.panelDataArrayChanged = true;\n    forceUpdate();\n  }, [forceUpdate]);\n\n  // (Re)calculate group layout whenever panels are registered or unregistered.\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  useIsomorphicLayoutEffect(() => {\n    if (eagerValuesRef.current.panelDataArrayChanged) {\n      eagerValuesRef.current.panelDataArrayChanged = false;\n      const {\n        autoSaveId,\n        onLayout,\n        storage\n      } = committedValuesRef.current;\n      const {\n        layout: prevLayout,\n        panelDataArray\n      } = eagerValuesRef.current;\n\n      // If this panel has been configured to persist sizing information,\n      // default size should be restored from local storage if possible.\n      let unsafeLayout = null;\n      if (autoSaveId) {\n        const state = loadPanelGroupState(autoSaveId, panelDataArray, storage);\n        if (state) {\n          panelSizeBeforeCollapseRef.current = new Map(Object.entries(state.expandToSizes));\n          unsafeLayout = state.layout;\n        }\n      }\n      if (unsafeLayout == null) {\n        unsafeLayout = calculateUnsafeDefaultLayout({\n          panelDataArray\n        });\n      }\n\n      // Validate even saved layouts in case something has changed since last render\n      // e.g. for pixel groups, this could be the size of the window\n      const nextLayout = validatePanelGroupLayout({\n        layout: unsafeLayout,\n        panelConstraints: panelDataArray.map(panelData => panelData.constraints)\n      });\n      if (!areEqual(prevLayout, nextLayout)) {\n        setLayout(nextLayout);\n        eagerValuesRef.current.layout = nextLayout;\n        if (onLayout) {\n          onLayout(nextLayout);\n        }\n        callPanelCallbacks(panelDataArray, nextLayout, panelIdToLastNotifiedSizeMapRef.current);\n      }\n    }\n  });\n\n  // Reset the cached layout if hidden by the Activity/Offscreen API\n  useIsomorphicLayoutEffect(() => {\n    const eagerValues = eagerValuesRef.current;\n    return () => {\n      eagerValues.layout = [];\n    };\n  }, []);\n  const registerResizeHandle = useCallback(dragHandleId => {\n    let isRTL = false;\n    const panelGroupElement = panelGroupElementRef.current;\n    if (panelGroupElement) {\n      const style = window.getComputedStyle(panelGroupElement, null);\n      if (style.getPropertyValue(\"direction\") === \"rtl\") {\n        isRTL = true;\n      }\n    }\n    return function resizeHandler(event) {\n      event.preventDefault();\n      const panelGroupElement = panelGroupElementRef.current;\n      if (!panelGroupElement) {\n        return () => null;\n      }\n      const {\n        direction,\n        dragState,\n        id: groupId,\n        keyboardResizeBy,\n        onLayout\n      } = committedValuesRef.current;\n      const {\n        layout: prevLayout,\n        panelDataArray\n      } = eagerValuesRef.current;\n      const {\n        initialLayout\n      } = dragState !== null && dragState !== void 0 ? dragState : {};\n      const pivotIndices = determinePivotIndices(groupId, dragHandleId, panelGroupElement);\n      let delta = calculateDeltaPercentage(event, dragHandleId, direction, dragState, keyboardResizeBy, panelGroupElement);\n      const isHorizontal = direction === \"horizontal\";\n      if (isHorizontal && isRTL) {\n        delta = -delta;\n      }\n      const panelConstraints = panelDataArray.map(panelData => panelData.constraints);\n      const nextLayout = adjustLayoutByDelta({\n        delta,\n        initialLayout: initialLayout !== null && initialLayout !== void 0 ? initialLayout : prevLayout,\n        panelConstraints,\n        pivotIndices,\n        prevLayout,\n        trigger: isKeyDown(event) ? \"keyboard\" : \"mouse-or-touch\"\n      });\n      const layoutChanged = !compareLayouts(prevLayout, nextLayout);\n\n      // Only update the cursor for layout changes triggered by touch/mouse events (not keyboard)\n      // Update the cursor even if the layout hasn't changed (we may need to show an invalid cursor state)\n      if (isPointerEvent(event) || isMouseEvent(event)) {\n        // Watch for multiple subsequent deltas; this might occur for tiny cursor movements.\n        // In this case, Panel sizes might not change–\n        // but updating cursor in this scenario would cause a flicker.\n        if (prevDeltaRef.current != delta) {\n          prevDeltaRef.current = delta;\n          if (!layoutChanged && delta !== 0) {\n            // If the pointer has moved too far to resize the panel any further, note this so we can update the cursor.\n            // This mimics VS Code behavior.\n            if (isHorizontal) {\n              reportConstraintsViolation(dragHandleId, delta < 0 ? EXCEEDED_HORIZONTAL_MIN : EXCEEDED_HORIZONTAL_MAX);\n            } else {\n              reportConstraintsViolation(dragHandleId, delta < 0 ? EXCEEDED_VERTICAL_MIN : EXCEEDED_VERTICAL_MAX);\n            }\n          } else {\n            reportConstraintsViolation(dragHandleId, 0);\n          }\n        }\n      }\n      if (layoutChanged) {\n        setLayout(nextLayout);\n        eagerValuesRef.current.layout = nextLayout;\n        if (onLayout) {\n          onLayout(nextLayout);\n        }\n        callPanelCallbacks(panelDataArray, nextLayout, panelIdToLastNotifiedSizeMapRef.current);\n      }\n    };\n  }, []);\n\n  // External APIs are safe to memoize via committed values ref\n  const resizePanel = useCallback((panelData, unsafePanelSize) => {\n    const {\n      onLayout\n    } = committedValuesRef.current;\n    const {\n      layout: prevLayout,\n      panelDataArray\n    } = eagerValuesRef.current;\n    const panelConstraintsArray = panelDataArray.map(panelData => panelData.constraints);\n    const {\n      panelSize,\n      pivotIndices\n    } = panelDataHelper(panelDataArray, panelData, prevLayout);\n    assert(panelSize != null, `Panel size not found for panel \"${panelData.id}\"`);\n    const isLastPanel = findPanelDataIndex(panelDataArray, panelData) === panelDataArray.length - 1;\n    const delta = isLastPanel ? panelSize - unsafePanelSize : unsafePanelSize - panelSize;\n    const nextLayout = adjustLayoutByDelta({\n      delta,\n      initialLayout: prevLayout,\n      panelConstraints: panelConstraintsArray,\n      pivotIndices,\n      prevLayout,\n      trigger: \"imperative-api\"\n    });\n    if (!compareLayouts(prevLayout, nextLayout)) {\n      setLayout(nextLayout);\n      eagerValuesRef.current.layout = nextLayout;\n      if (onLayout) {\n        onLayout(nextLayout);\n      }\n      callPanelCallbacks(panelDataArray, nextLayout, panelIdToLastNotifiedSizeMapRef.current);\n    }\n  }, []);\n  const reevaluatePanelConstraints = useCallback((panelData, prevConstraints) => {\n    const {\n      layout,\n      panelDataArray\n    } = eagerValuesRef.current;\n    const {\n      collapsedSize: prevCollapsedSize = 0,\n      collapsible: prevCollapsible\n    } = prevConstraints;\n    const {\n      collapsedSize: nextCollapsedSize = 0,\n      collapsible: nextCollapsible,\n      maxSize: nextMaxSize = 100,\n      minSize: nextMinSize = 0\n    } = panelData.constraints;\n    const {\n      panelSize: prevPanelSize\n    } = panelDataHelper(panelDataArray, panelData, layout);\n    if (prevPanelSize == null) {\n      // It's possible that the panels in this group have changed since the last render\n      return;\n    }\n    if (prevCollapsible && nextCollapsible && fuzzyNumbersEqual$1(prevPanelSize, prevCollapsedSize)) {\n      if (!fuzzyNumbersEqual$1(prevCollapsedSize, nextCollapsedSize)) {\n        resizePanel(panelData, nextCollapsedSize);\n      }\n    } else if (prevPanelSize < nextMinSize) {\n      resizePanel(panelData, nextMinSize);\n    } else if (prevPanelSize > nextMaxSize) {\n      resizePanel(panelData, nextMaxSize);\n    }\n  }, [resizePanel]);\n\n  // TODO Multiple drag handles can be active at the same time so this API is a bit awkward now\n  const startDragging = useCallback((dragHandleId, event) => {\n    const {\n      direction\n    } = committedValuesRef.current;\n    const {\n      layout\n    } = eagerValuesRef.current;\n    if (!panelGroupElementRef.current) {\n      return;\n    }\n    const handleElement = getResizeHandleElement(dragHandleId, panelGroupElementRef.current);\n    assert(handleElement, `Drag handle element not found for id \"${dragHandleId}\"`);\n    const initialCursorPosition = getResizeEventCursorPosition(direction, event);\n    setDragState({\n      dragHandleId,\n      dragHandleRect: handleElement.getBoundingClientRect(),\n      initialCursorPosition,\n      initialLayout: layout\n    });\n  }, []);\n  const stopDragging = useCallback(() => {\n    setDragState(null);\n  }, []);\n  const unregisterPanel = useCallback(panelData => {\n    const {\n      panelDataArray\n    } = eagerValuesRef.current;\n    const index = findPanelDataIndex(panelDataArray, panelData);\n    if (index >= 0) {\n      panelDataArray.splice(index, 1);\n\n      // TRICKY\n      // When a panel is removed from the group, we should delete the most recent prev-size entry for it.\n      // If we don't do this, then a conditionally rendered panel might not call onResize when it's re-mounted.\n      // Strict effects mode makes this tricky though because all panels will be registered, unregistered, then re-registered on mount.\n      delete panelIdToLastNotifiedSizeMapRef.current[panelData.id];\n      eagerValuesRef.current.panelDataArrayChanged = true;\n      forceUpdate();\n    }\n  }, [forceUpdate]);\n  const context = useMemo(() => ({\n    collapsePanel,\n    direction,\n    dragState,\n    expandPanel,\n    getPanelSize,\n    getPanelStyle,\n    groupId,\n    isPanelCollapsed,\n    isPanelExpanded,\n    reevaluatePanelConstraints,\n    registerPanel,\n    registerResizeHandle,\n    resizePanel,\n    startDragging,\n    stopDragging,\n    unregisterPanel,\n    panelGroupElement: panelGroupElementRef.current\n  }), [collapsePanel, dragState, direction, expandPanel, getPanelSize, getPanelStyle, groupId, isPanelCollapsed, isPanelExpanded, reevaluatePanelConstraints, registerPanel, registerResizeHandle, resizePanel, startDragging, stopDragging, unregisterPanel]);\n  const style = {\n    display: \"flex\",\n    flexDirection: direction === \"horizontal\" ? \"row\" : \"column\",\n    height: \"100%\",\n    overflow: \"hidden\",\n    width: \"100%\"\n  };\n  return createElement(PanelGroupContext.Provider, {\n    value: context\n  }, createElement(Type, {\n    ...rest,\n    children,\n    className: classNameFromProps,\n    id: idFromProps,\n    ref: panelGroupElementRef,\n    style: {\n      ...style,\n      ...styleFromProps\n    },\n    // CSS selectors\n    [DATA_ATTRIBUTES.group]: \"\",\n    [DATA_ATTRIBUTES.groupDirection]: direction,\n    [DATA_ATTRIBUTES.groupId]: groupId\n  }));\n}\nconst PanelGroup = forwardRef((props, ref) => createElement(PanelGroupWithForwardedRef, {\n  ...props,\n  forwardedRef: ref\n}));\nPanelGroupWithForwardedRef.displayName = \"PanelGroup\";\nPanelGroup.displayName = \"forwardRef(PanelGroup)\";\nfunction findPanelDataIndex(panelDataArray, panelData) {\n  return panelDataArray.findIndex(prevPanelData => prevPanelData === panelData || prevPanelData.id === panelData.id);\n}\nfunction panelDataHelper(panelDataArray, panelData, layout) {\n  const panelIndex = findPanelDataIndex(panelDataArray, panelData);\n  const isLastPanel = panelIndex === panelDataArray.length - 1;\n  const pivotIndices = isLastPanel ? [panelIndex - 1, panelIndex] : [panelIndex, panelIndex + 1];\n  const panelSize = layout[panelIndex];\n  return {\n    ...panelData.constraints,\n    panelSize,\n    pivotIndices\n  };\n}\n\n// https://www.w3.org/WAI/ARIA/apg/patterns/windowsplitter/\n\nfunction useWindowSplitterResizeHandlerBehavior({\n  disabled,\n  handleId,\n  resizeHandler,\n  panelGroupElement\n}) {\n  useEffect(() => {\n    if (disabled || resizeHandler == null || panelGroupElement == null) {\n      return;\n    }\n    const handleElement = getResizeHandleElement(handleId, panelGroupElement);\n    if (handleElement == null) {\n      return;\n    }\n    const onKeyDown = event => {\n      if (event.defaultPrevented) {\n        return;\n      }\n      switch (event.key) {\n        case \"ArrowDown\":\n        case \"ArrowLeft\":\n        case \"ArrowRight\":\n        case \"ArrowUp\":\n        case \"End\":\n        case \"Home\":\n          {\n            event.preventDefault();\n            resizeHandler(event);\n            break;\n          }\n        case \"F6\":\n          {\n            event.preventDefault();\n            const groupId = handleElement.getAttribute(DATA_ATTRIBUTES.groupId);\n            assert(groupId, `No group element found for id \"${groupId}\"`);\n            const handles = getResizeHandleElementsForGroup(groupId, panelGroupElement);\n            const index = getResizeHandleElementIndex(groupId, handleId, panelGroupElement);\n            assert(index !== null, `No resize element found for id \"${handleId}\"`);\n            const nextIndex = event.shiftKey ? index > 0 ? index - 1 : handles.length - 1 : index + 1 < handles.length ? index + 1 : 0;\n            const nextHandle = handles[nextIndex];\n            nextHandle.focus();\n            break;\n          }\n      }\n    };\n    handleElement.addEventListener(\"keydown\", onKeyDown);\n    return () => {\n      handleElement.removeEventListener(\"keydown\", onKeyDown);\n    };\n  }, [panelGroupElement, disabled, handleId, resizeHandler]);\n}\n\nfunction PanelResizeHandle({\n  children = null,\n  className: classNameFromProps = \"\",\n  disabled = false,\n  hitAreaMargins,\n  id: idFromProps,\n  onBlur,\n  onClick,\n  onDragging,\n  onFocus,\n  onPointerDown,\n  onPointerUp,\n  style: styleFromProps = {},\n  tabIndex = 0,\n  tagName: Type = \"div\",\n  ...rest\n}) {\n  var _hitAreaMargins$coars, _hitAreaMargins$fine;\n  const elementRef = useRef(null);\n\n  // Use a ref to guard against users passing inline props\n  const callbacksRef = useRef({\n    onClick,\n    onDragging,\n    onPointerDown,\n    onPointerUp\n  });\n  useEffect(() => {\n    callbacksRef.current.onClick = onClick;\n    callbacksRef.current.onDragging = onDragging;\n    callbacksRef.current.onPointerDown = onPointerDown;\n    callbacksRef.current.onPointerUp = onPointerUp;\n  });\n  const panelGroupContext = useContext(PanelGroupContext);\n  if (panelGroupContext === null) {\n    throw Error(`PanelResizeHandle components must be rendered within a PanelGroup container`);\n  }\n  const {\n    direction,\n    groupId,\n    registerResizeHandle: registerResizeHandleWithParentGroup,\n    startDragging,\n    stopDragging,\n    panelGroupElement\n  } = panelGroupContext;\n  const resizeHandleId = useUniqueId(idFromProps);\n  const [state, setState] = useState(\"inactive\");\n  const [isFocused, setIsFocused] = useState(false);\n  const [resizeHandler, setResizeHandler] = useState(null);\n  const committedValuesRef = useRef({\n    state\n  });\n  useIsomorphicLayoutEffect(() => {\n    committedValuesRef.current.state = state;\n  });\n  useEffect(() => {\n    if (disabled) {\n      setResizeHandler(null);\n    } else {\n      const resizeHandler = registerResizeHandleWithParentGroup(resizeHandleId);\n      setResizeHandler(() => resizeHandler);\n    }\n  }, [disabled, resizeHandleId, registerResizeHandleWithParentGroup]);\n\n  // Extract hit area margins before passing them to the effect's dependency array\n  // so that inline object values won't trigger re-renders\n  const coarseHitAreaMargins = (_hitAreaMargins$coars = hitAreaMargins === null || hitAreaMargins === void 0 ? void 0 : hitAreaMargins.coarse) !== null && _hitAreaMargins$coars !== void 0 ? _hitAreaMargins$coars : 15;\n  const fineHitAreaMargins = (_hitAreaMargins$fine = hitAreaMargins === null || hitAreaMargins === void 0 ? void 0 : hitAreaMargins.fine) !== null && _hitAreaMargins$fine !== void 0 ? _hitAreaMargins$fine : 5;\n  useEffect(() => {\n    if (disabled || resizeHandler == null) {\n      return;\n    }\n    const element = elementRef.current;\n    assert(element, \"Element ref not attached\");\n    let didMove = false;\n    const setResizeHandlerState = (action, isActive, event) => {\n      if (!isActive) {\n        setState(\"inactive\");\n        return;\n      }\n      switch (action) {\n        case \"down\":\n          {\n            setState(\"drag\");\n            didMove = false;\n            assert(event, 'Expected event to be defined for \"down\" action');\n            startDragging(resizeHandleId, event);\n            const {\n              onDragging,\n              onPointerDown\n            } = callbacksRef.current;\n            onDragging === null || onDragging === void 0 ? void 0 : onDragging(true);\n            onPointerDown === null || onPointerDown === void 0 ? void 0 : onPointerDown();\n            break;\n          }\n        case \"move\":\n          {\n            const {\n              state\n            } = committedValuesRef.current;\n            didMove = true;\n            if (state !== \"drag\") {\n              setState(\"hover\");\n            }\n            assert(event, 'Expected event to be defined for \"move\" action');\n            resizeHandler(event);\n            break;\n          }\n        case \"up\":\n          {\n            setState(\"hover\");\n            stopDragging();\n            const {\n              onClick,\n              onDragging,\n              onPointerUp\n            } = callbacksRef.current;\n            onDragging === null || onDragging === void 0 ? void 0 : onDragging(false);\n            onPointerUp === null || onPointerUp === void 0 ? void 0 : onPointerUp();\n            if (!didMove) {\n              onClick === null || onClick === void 0 ? void 0 : onClick();\n            }\n            break;\n          }\n      }\n    };\n    return registerResizeHandle(resizeHandleId, element, direction, {\n      coarse: coarseHitAreaMargins,\n      fine: fineHitAreaMargins\n    }, setResizeHandlerState);\n  }, [coarseHitAreaMargins, direction, disabled, fineHitAreaMargins, registerResizeHandleWithParentGroup, resizeHandleId, resizeHandler, startDragging, stopDragging]);\n  useWindowSplitterResizeHandlerBehavior({\n    disabled,\n    handleId: resizeHandleId,\n    resizeHandler,\n    panelGroupElement\n  });\n  const style = {\n    touchAction: \"none\",\n    userSelect: \"none\"\n  };\n  return createElement(Type, {\n    ...rest,\n    children,\n    className: classNameFromProps,\n    id: idFromProps,\n    onBlur: () => {\n      setIsFocused(false);\n      onBlur === null || onBlur === void 0 ? void 0 : onBlur();\n    },\n    onFocus: () => {\n      setIsFocused(true);\n      onFocus === null || onFocus === void 0 ? void 0 : onFocus();\n    },\n    ref: elementRef,\n    role: \"separator\",\n    style: {\n      ...style,\n      ...styleFromProps\n    },\n    tabIndex,\n    // CSS selectors\n    [DATA_ATTRIBUTES.groupDirection]: direction,\n    [DATA_ATTRIBUTES.groupId]: groupId,\n    [DATA_ATTRIBUTES.resizeHandle]: \"\",\n    [DATA_ATTRIBUTES.resizeHandleActive]: state === \"drag\" ? \"pointer\" : isFocused ? \"keyboard\" : undefined,\n    [DATA_ATTRIBUTES.resizeHandleEnabled]: !disabled,\n    [DATA_ATTRIBUTES.resizeHandleId]: resizeHandleId,\n    [DATA_ATTRIBUTES.resizeHandleState]: state\n  });\n}\nPanelResizeHandle.displayName = \"PanelResizeHandle\";\n\nfunction usePanelGroupContext() {\n  const context = useContext(PanelGroupContext);\n  return {\n    direction: context === null || context === void 0 ? void 0 : context.direction,\n    groupId: context === null || context === void 0 ? void 0 : context.groupId\n  };\n}\n\nfunction getPanelElement(id, scope = document) {\n  const element = scope.querySelector(`[data-panel-id=\"${id}\"]`);\n  if (element) {\n    return element;\n  }\n  return null;\n}\n\nfunction getPanelElementsForGroup(groupId, scope = document) {\n  return Array.from(scope.querySelectorAll(`[data-panel][data-panel-group-id=\"${groupId}\"]`));\n}\n\nfunction getIntersectingRectangle(rectOne, rectTwo, strict) {\n  if (!intersects(rectOne, rectTwo, strict)) {\n    return {\n      x: 0,\n      y: 0,\n      width: 0,\n      height: 0\n    };\n  }\n  return {\n    x: Math.max(rectOne.x, rectTwo.x),\n    y: Math.max(rectOne.y, rectTwo.y),\n    width: Math.min(rectOne.x + rectOne.width, rectTwo.x + rectTwo.width) - Math.max(rectOne.x, rectTwo.x),\n    height: Math.min(rectOne.y + rectOne.height, rectTwo.y + rectTwo.height) - Math.max(rectOne.y, rectTwo.y)\n  };\n}\n\nexport { DATA_ATTRIBUTES, Panel, PanelGroup, PanelResizeHandle, assert, disableGlobalCursorStyles, enableGlobalCursorStyles, getIntersectingRectangle, getPanelElement, getPanelElementsForGroup, getPanelGroupElement, getResizeHandleElement, getResizeHandleElementIndex, getResizeHandleElementsForGroup, getResizeHandlePanelIds, intersects, setNonce, usePanelGroupContext };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}